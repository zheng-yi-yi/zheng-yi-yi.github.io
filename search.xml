<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【数据结构】二叉树的遍历</title>
      <link href="/2024/01/24/dsa-08-Tree-Traversal/"/>
      <url>/2024/01/24/dsa-08-Tree-Traversal/</url>
      
        <content type="html"><![CDATA[<h1>二叉树的遍历</h1><p>遍历是数据结构中的常见操作（访问数据结构中的所有元素）。</p><p>线性数据结构的遍历比较简单，正序遍历或逆序遍历。而对于二叉树来讲，根据节点访问顺序的不同，可以分为四种：</p><ul><li>前序遍历（Preorder Traversal）</li><li>中序遍历（Inorder Traversal）</li><li>后序遍历（Postorder Traversal）</li><li>层序遍历（Level Order Traversal）</li></ul><p>下面我们来看看他们的特点。</p><h1>前序遍历（Pre-Order Traversal）</h1><p><strong>前序遍历二叉树，就是先访问根结点（中间节点），再前序遍历左子树，最后前序遍历右子树</strong>。</p><img src="/2024/01/24/dsa-08-Tree-Traversal/Pre-Order-Traversal.png" class="" title="Pre-Order-Traversal"><p>如上图：</p><p>我们再回想一下，前序遍历的访问顺序是什么？首先根节点肯定是最先被访问，然后是左子树，最后才是右子树。</p><p>因此在上图中，前序遍历的访问顺序如下：</p><ol><li>访问根节点 F</li><li>访问左子树 B<ul><li>访问左子节点 A</li><li>访问右子节点 D<ul><li>访问左子节点 C</li><li>访问右子节点 E</li></ul></li></ul></li><li>访问右子树 G<ul><li>访问右子节点 I<ul><li>访问左子节点 H</li></ul></li></ul></li></ol><p>前序遍历的顺序是 <code>[F]-&gt;[B]-&gt;[A]-&gt;[D]-&gt;[C]-&gt;[E]-&gt;[G]-&gt;[I]-&gt;[H]</code>。这表示在按照前序遍历方式访问树的时候，首先访问根节点 F，然后按照左子树和右子树的顺序递归进行访问。</p><p>由于树本身是一种<strong>递归定义</strong>的数据结构，因此很自然也可以用递归的方式来遍历。</p><p>用递归法对二叉树进行前序遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历，获取二叉树节点的值列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 二叉树的根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 二叉树节点值的列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    preorder(root, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用前序遍历的方式递归处理二叉树节点，并将节点值添加到结果列表中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 当前处理的二叉树节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result 存储节点值的列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果节点为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前节点的值添加到结果列表中</span></span><br><span class="line">    result.add(node.val);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归处理左子树</span></span><br><span class="line">    preorder(node.left, result);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归处理右子树</span></span><br><span class="line">    preorder(node.right, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，递归的方式去前序遍历二叉树很简单，思路也很清晰。</p><p>如果使用迭代的方式实现前序遍历，可以使用栈数据结构来模拟递归的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以迭代方式实现前序遍历二叉树节点的值列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 二叉树的根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 二叉树节点值的列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用栈来模拟递归的过程</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将根节点入栈</span></span><br><span class="line">    stack.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 出栈当前节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> stack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前节点的值添加到结果列表中</span></span><br><span class="line">        result.add(current.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先将右子树入栈，再将左子树入栈</span></span><br><span class="line">        <span class="keyword">if</span>(current.right != <span class="literal">null</span>) stack.push(current.right);</span><br><span class="line">        <span class="keyword">if</span>(current.left != <span class="literal">null</span>) stack.push(current.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个迭代的实现使用栈来模拟递归，首先将根节点（也就是中间节点）入栈，然后在循环中弹出当前节点，将其值添加到<code>result</code>中，并按照<strong>先右后左</strong>的顺序将右子树和左子树入栈。这样可以模拟前序遍历的顺序。</p><blockquote><ul><li>Q：为什么要先加入右节点，再加入左节点呢？</li><li>A：<strong>因为这样出栈的时候才是先左后右的顺序</strong>。</li></ul></blockquote><h1>中序遍历（In-Order Traversal）</h1><p>中序遍历是<strong>先访问左节点，再访问根节点，最后访问右节点</strong>。</p><img src="/2024/01/24/dsa-08-Tree-Traversal/In-Order-Traversal.png" class="" title="In-Order-Traversal"><p>以上图为例：</p><ul><li>（1）从根节点 F 开始，按照中序遍历的规则，首先遍历F的左子树B。<ul><li>遍历B的左子树A<ul><li>遍历A的左子树，为空，跳过。</li><li>遍历A的根节点，<strong>输出A</strong>。</li><li>遍历A的右子树，为空，跳过。</li></ul></li><li>遍历B的根节点，<strong>输出B</strong>。</li><li>遍历B的右子树D<ul><li>遍历D的左子树C<ul><li>遍历C的左子树，为空，跳过。</li><li>遍历C的根节点，<strong>输出C</strong>。</li><li>遍历C的右子树，为空，跳过。</li></ul></li><li>遍历D的根节点，<strong>输出D</strong>。</li><li>遍历D的右子树E<ul><li>遍历E的左子树，为空，跳过。</li><li>遍历E的根节点，<strong>输出E</strong>。</li><li>遍历E的右子树，为空，跳过。</li></ul></li></ul></li></ul></li><li>（2）现在根节点 F 的左子树遍历完了，接着遍历F的根节点，<strong>输出F</strong></li><li>（3）最后遍历F的右子树G<ul><li>遍历G的左子树，为空，跳过。</li><li>遍历G的根节点，<strong>输出G</strong>。</li><li>遍历G的右子树I<ul><li>遍历I的左子树H。<ul><li>遍历H的左子树，为空，跳过。</li><li>遍历H的根节点，<strong>输出H</strong>。</li><li>遍历H的右子树，为空，跳过。</li></ul></li><li>遍历I的根节点，<strong>输出I</strong>。</li><li>遍历I的右子树，为空，跳过。</li></ul></li></ul></li></ul><p>遍历逻辑写的很清楚了，因此，中序遍历的顺序为 <code>[A]-&gt;[B]-&gt;[C]-&gt;[D]-&gt;[E]-&gt;[F]-&gt;[G]-&gt;[H]-&gt;[I]</code>。</p><p>实际上，上图二叉树是一个二叉搜索树。我们发现，对于二叉搜索树来讲，中序遍历后的结果是升序的。这很有意思。由于在二叉搜索树中，左子树的值小于根节点的值，右子树的值大于根节点的值。所以结果是显而易见的。如果我们先访问右子树，再访问根结点，最后访问左子树，此时遍历的结果是降序的。</p><blockquote><p>中序遍历实际上就是将根节点放在左子树和右子树的中间进行遍历，不一定非要先访问左子树，也可以先访问右子树，然后访问根节点，最后访问左子树。</p></blockquote><blockquote><ul><li>Q：先访问右子树，然后访问根节点，最后访问左子树，也是中序遍历嘛？</li><li>A：<strong>二叉树的遍历实际上是一种基于根节点的划分，将根节点放在左右子树的中间进行遍历就算是中序遍历</strong>，因此不一定非要先访问左子树，也可以先访问右子树，然后访问根节点，最后访问左子树，根据我们的具体需求。</li></ul></blockquote><p>代码实现如下：</p><ul><li>递归法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历，获取二叉树节点的值列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 二叉树的根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 二叉树节点值的列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    inorder(root, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用中序遍历的方式递归处理二叉树节点，并将节点值添加到结果列表中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 当前处理的二叉树节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result 存储节点值的列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果节点为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归处理左子树</span></span><br><span class="line">    inorder(node.left, result);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前节点的值添加到结果列表中</span></span><br><span class="line">    result.add(node.val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归处理右子树</span></span><br><span class="line">    inorder(node.right, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>迭代法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历二叉树，返回一个包含节点值的列表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 二叉树的根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 中序遍历结果的列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个存储结果的列表</span></span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果根节点为空，直接返回空列表</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个栈用于辅助遍历</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点初始化为根节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环条件：当前节点不为空，或者栈不为空</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点不为空，将其入栈并移动到左子树</span></span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点为空，说明左子树已经遍历完毕</span></span><br><span class="line">            <span class="comment">// 弹出栈顶节点，添加其值到结果列表</span></span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            result.add(cur.val);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动到右子树</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最终的中序遍历结果列表</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>后序遍历（Post-Order Traversal）</h1><p>看完前两个遍历，我们也能猜出后序遍历的规则了。</p><p>没错，后序遍历的遍历顺序为左子树、右子树、根节点。具体来说，在后序遍历中，我们先遍历左子树，然后遍历右子树，最后访问根节点。</p><img src="/2024/01/24/dsa-08-Tree-Traversal/Post-Order-Traversal.png" class="" title="Post-Order-Traversal"><p>以上图为例：</p><ul><li>（1）从根节点 F 开始，按照后序遍历的规则，首先遍历F的左子树B。<ul><li>遍历B的左子树A<ul><li>遍历A的左子树，为空，跳过。</li><li>遍历A的右子树，为空，跳过。</li><li>遍历A的根节点，<strong>输出A</strong>。</li></ul></li><li>遍历B的右子树D<ul><li>遍历D的左子树C<ul><li>遍历C的左子树，为空，跳过。</li><li>遍历C的右子树，为空，跳过。</li><li>遍历C的根节点，<strong>输出C</strong>。</li></ul></li><li>遍历D的右子树E<ul><li>遍历E的左子树，为空，跳过。</li><li>遍历E的右子树，为空，跳过。</li><li>遍历E的根节点，<strong>输出E</strong>。</li></ul></li><li>遍历D的根节点，<strong>输出D</strong>。</li></ul></li><li>遍历B的根节点，<strong>输出B</strong>。</li></ul></li><li>现在根节点 F 的左子树遍历完了，接着遍历F的右子树G<ul><li>遍历G的左子树，为空，跳过。</li><li>遍历G的右子树I<ul><li>遍历I的左子树H。<ul><li>遍历H的左子树，为空，跳过。</li><li>遍历H的右子树，为空，跳过。</li><li>遍历H的根节点，<strong>输出H</strong>。</li></ul></li><li>遍历I的右子树，为空，跳过。</li><li>遍历I的根节点，<strong>输出I</strong>。</li></ul></li><li>遍历G的根节点，<strong>输出G</strong>。</li></ul></li><li>现在根节点 F 的左右子树都遍历完了，最后再遍历F的根节点，<strong>输出F</strong>。</li></ul><p>因此，后序遍历的顺序为 <code>[A]-&gt;[C]-&gt;[E]-&gt;[D]-&gt;[B]-&gt;[H]-&gt;[I]-&gt;[G]-&gt;[F]</code>。</p><p>代码实现如下：</p><ul><li>递归法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历，获取二叉树节点的值列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 二叉树的根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 二叉树节点值的列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    postorder(root, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用中序遍历的方式递归处理二叉树节点，并将节点值添加到结果列表中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 当前处理的二叉树节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result 存储节点值的列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果节点为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归处理左子树</span></span><br><span class="line">    postorder(node.left, result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归处理右子树</span></span><br><span class="line">    postorder(node.right, result);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前节点的值添加到结果列表中</span></span><br><span class="line">    result.add(node.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>迭代法：</li></ul><p>这里用到一个小技巧。和先序遍历类似，我们先访问根节点，然后遍历右子树，最后遍历左子树，此时遍历的顺序是<code>根右左</code>，因此我们将<code>result</code>反转后就得到了后序遍历的结果数组，即遍历顺序是<code>左右根</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历二叉树，返回一个包含节点值的列表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 二叉树的根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 后序遍历结果的列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个存储结果的列表</span></span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果根节点为空，直接返回空列表</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个栈用于辅助遍历</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将根节点压入栈</span></span><br><span class="line">    stack.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环条件：栈不为空</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 弹出栈顶节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将节点值添加到结果列表</span></span><br><span class="line">        result.add(node.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：这里与前序遍历的顺序相反</span></span><br><span class="line">        <span class="comment">// 先将右子树压入栈，再将左子树压入栈</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) stack.push(node.right);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) stack.push(node.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于后序遍历是“左右根”的顺序，因此将“根右左”的顺序翻转即可</span></span><br><span class="line">    Collections.reverse(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最终的后序遍历结果列表</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>小结 | 前中后序遍历</h1><img src="/2024/01/24/dsa-08-Tree-Traversal/%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%861.png" class="" title="前中后序遍历1"><img src="/2024/01/24/dsa-08-Tree-Traversal/%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%862.png" class="" title="前中后序遍历2"><p>让我们用 <code>L</code>、<code>D</code>、<code>R</code> 分别表示遍历左子树、访问根节点和遍历右子树。</p><p>那么：</p><ul><li><code>D L R</code>：<strong>先序遍历</strong>二叉树的顺序（或者<code>D R L</code>）</li><li><code>L D R</code>：<strong>中序遍历</strong>二叉树的顺序（或者<code>R D L</code>）</li><li><code>L R D</code>：<strong>后序遍历</strong>二叉树的顺序（或者<code>R L D</code>）</li></ul><blockquote><p>备注：我们主要观察访问根节点的访问时机，就可以判断属于哪种遍历。</p></blockquote><h1>层序遍历（Level Order Traversal）</h1><p>最后是层序遍历。</p><p>层序遍历，就是从上到下，从左到右依次访问每一个节点。</p><img src="/2024/01/24/dsa-08-Tree-Traversal/LevelOrderTraversal.png" class="" title="LevelOrderTraversal"><p>如上图所示。</p><p>代码如下：</p><ul><li>递归形式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量，用于存储最终结果</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数，用于调用层序遍历方法并返回最终结果</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    levelOrder(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层序遍历方法，采用递归方式实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">(TreeNode node, Integer level)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前节点为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果结果列表的大小小于等于当前层级，则需要添加新的层</span></span><br><span class="line">    <span class="keyword">if</span> (result.size() &lt;= level) &#123;</span><br><span class="line">        List&lt;Integer&gt; item = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        result.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前节点的值添加到对应层的列表中</span></span><br><span class="line">    result.get(level).add(node.val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归调用左子树和右子树，并将层级加一</span></span><br><span class="line">    levelOrder(node.left, level + <span class="number">1</span>);</span><br><span class="line">    levelOrder(node.right, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>迭代形式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量，用于存储最终结果</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数，用于调用层序遍历方法并返回最终结果</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    levelOrder(root);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层序遍历方法：迭代</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果根节点为空，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个队列用于存储节点</span></span><br><span class="line">    Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 将根节点入队</span></span><br><span class="line">    que.offer(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环直到队列为空</span></span><br><span class="line">    <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 用于存储当前层的节点值的列表</span></span><br><span class="line">        List&lt;Integer&gt; itemList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取当前层的节点数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历当前层的所有节点</span></span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 出队一个节点</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmpNode</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="comment">// 将节点值添加到当前层的列表中</span></span><br><span class="line">            itemList.add(tmpNode.val);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果左子树不为空，将左子树节点入队</span></span><br><span class="line">            <span class="keyword">if</span> (tmpNode.left != <span class="literal">null</span>) que.offer(tmpNode.left);</span><br><span class="line">            <span class="comment">// 如果右子树不为空，将右子树节点入队</span></span><br><span class="line">            <span class="keyword">if</span> (tmpNode.right != <span class="literal">null</span>) que.offer(tmpNode.right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前层节点数量减一</span></span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前层的节点值列表添加到最终结果中</span></span><br><span class="line">        result.add(itemList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>复习巩固</h1><ul><li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的前序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树的遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具类】打印二叉树</title>
      <link href="/2024/01/23/dsa-07-printTreeTool/"/>
      <url>/2024/01/23/dsa-07-printTreeTool/</url>
      
        <content type="html"><![CDATA[<h1>打印二叉树</h1><h2 id="介绍">介绍</h2><p>二叉树是一种重要的数据结构，在编写程序时，经常需要以可读性较强的方式打印二叉树结构，以便更好地理解和调试代码。</p><p>本节将介绍一个简单而有效的二叉树打印工具，以及如何使用该工具。</p><h2 id="使用效果">使用效果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">BinarySerchTree&lt;Integer&gt; bst = <span class="keyword">new</span> <span class="title class_">BinarySerchTree</span>&lt;&gt;(); <span class="comment">// 自己写的一个二叉搜索树</span></span><br><span class="line"><span class="comment">// 添加若干节点</span></span><br><span class="line">bst.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">15</span>));</span><br><span class="line">bst.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">7</span>));</span><br><span class="line">bst.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">26</span>));</span><br><span class="line">bst.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">13</span>));</span><br><span class="line">bst.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>));</span><br><span class="line">bst.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>));</span><br><span class="line">bst.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">19</span>));</span><br><span class="line"><span class="comment">// 调用打印方法</span></span><br><span class="line">bst.printTree();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%88%E6%9E%9C.png" alt="二叉树打印工具的使用效果"></p><h2 id="工具代码">工具代码</h2><p>这个二叉树打印的工具类有两个，分别是 <code>PrintableNode</code> 接口和 <code>TreePrinter</code> 工具类。</p><h3 id="PrintableNode-接口">PrintableNode 接口</h3><p>首先，让我们看一下 <code>PrintableNode</code> 接口的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PrintableNode</span> &#123;</span><br><span class="line">    PrintableNode <span class="title function_">getLeft</span><span class="params">()</span>;</span><br><span class="line">    PrintableNode <span class="title function_">getRight</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getData</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口定义了三个方法：</p><ul><li><code>getLeft()</code>: 获取左子节点</li><li><code>getRight()</code>: 获取右子节点</li><li><code>getData()</code>: 获取要打印的节点的值</li></ul><p>因此，我们自己的节点类必须<code>implements</code>这个<code>PrintableNode</code>接口，然后实现这三个方法。</p><h3 id="TreePrinter-工具类">TreePrinter 工具类</h3><p>现在，我们来看一下 <code>TreePrinter</code> 工具类的代码。</p><p>这个工具类提供了一个静态方法 <code>print</code>，用于打印二叉树结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树打印工具类，用于以可读性强的方式打印二叉树结构。</span></span><br><span class="line"><span class="comment"> * 该工具类提供了一个静态方法 `print`，用于打印实现了 `PrintableNode` 接口的树节点。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 翼同学</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreePrinter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印二叉树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 二叉树的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(PrintableNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 存储每一层的节点值</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; lines = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前层的节点</span></span><br><span class="line">        List&lt;PrintableNode&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 下一层的节点</span></span><br><span class="line">        List&lt;PrintableNode&gt; next = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将根节点添加到当前层</span></span><br><span class="line">        level.add(root);</span><br><span class="line">        <span class="comment">// 记录当前层的节点数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nn</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录最宽的节点值的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">widest</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环遍历树的每一层</span></span><br><span class="line">        <span class="keyword">while</span> (nn != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 存储当前层的节点值</span></span><br><span class="line">            List&lt;String&gt; line = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重置节点数量</span></span><br><span class="line">            nn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历当前层的每个节点</span></span><br><span class="line">            <span class="keyword">for</span> (PrintableNode n : level) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 节点为空时，添加占位符，并在下一层添加两个null占位符</span></span><br><span class="line">                    line.add(<span class="literal">null</span>);</span><br><span class="line">                    next.add(<span class="literal">null</span>);</span><br><span class="line">                    next.add(<span class="literal">null</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 节点不为空时，获取节点值，并添加到当前层的节点值列表中</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> n.getData();</span><br><span class="line">                    line.add(aa);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 更新最宽节点值的长度</span></span><br><span class="line">                    <span class="keyword">if</span> (aa.length() &gt; widest) widest = aa.length();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 在下一层添加左右子节点，并更新节点数量</span></span><br><span class="line">                    next.add(n.getLeft());</span><br><span class="line">                    next.add(n.getRight());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (n.getLeft() != <span class="literal">null</span>) nn++;</span><br><span class="line">                    <span class="keyword">if</span> (n.getRight() != <span class="literal">null</span>) nn++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调整最宽节点值长度为偶数</span></span><br><span class="line">            <span class="keyword">if</span> (widest % <span class="number">2</span> == <span class="number">1</span>) widest++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前层的节点值列表添加到总的节点值列表中</span></span><br><span class="line">            lines.add(line);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换当前层和下一层的节点列表，并清空下一层的列表</span></span><br><span class="line">            List&lt;PrintableNode&gt; tmp = level;</span><br><span class="line">            level = next;</span><br><span class="line">            next = tmp;</span><br><span class="line">            next.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算每个节点值的宽度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">perpiece</span> <span class="operator">=</span> lines.get(lines.size() - <span class="number">1</span>).size() * (widest + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历每一层的节点值列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lines.size(); i++) &#123;</span><br><span class="line">            List&lt;String&gt; line = lines.get(i);</span><br><span class="line">            <span class="comment">// 计算每个节点值的半宽度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">hpw</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor(perpiece / <span class="number">2f</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 非第一层时，处理节点连接线</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; line.size(); j++) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 分割节点</span></span><br><span class="line">                    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (line.get(j - <span class="number">1</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            c = (line.get(j) != <span class="literal">null</span>) ? <span class="string">&#x27;┴&#x27;</span> : <span class="string">&#x27;┘&#x27;</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (j &lt; line.size() &amp;&amp; line.get(j) != <span class="literal">null</span>) c = <span class="string">&#x27;└&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(c);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 线和空格</span></span><br><span class="line">                    <span class="keyword">if</span> (line.get(j) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; perpiece - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                            System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; hpw; k++) &#123;</span><br><span class="line">                            System.out.print(j % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">&quot; &quot;</span> : <span class="string">&quot;─&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.print(j % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">&quot;┌&quot;</span> : <span class="string">&quot;┐&quot;</span>);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; hpw; k++) &#123;</span><br><span class="line">                            System.out.print(j % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">&quot;─&quot;</span> : <span class="string">&quot; &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印数字行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; line.size(); j++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> line.get(j);</span><br><span class="line">                <span class="keyword">if</span> (f == <span class="literal">null</span>) f = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="comment">// 计算节点值两侧的空格数量</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">gap1</span> <span class="operator">=</span> (<span class="type">int</span>) Math.ceil(perpiece / <span class="number">2f</span> - f.length() / <span class="number">2f</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">gap2</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor(perpiece / <span class="number">2f</span> - f.length() / <span class="number">2f</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 数字</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; gap1; k++) &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(f);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; gap2; k++) &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每层节点值宽度减半</span></span><br><span class="line">            perpiece /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何使用？">如何使用？</h2><p>现在，我们将演示如何使用 <code>TreePrinter</code> 工具类来打印二叉树。</p><p>首先，确保你的二叉树节点实现了 <code>PrintableNode</code> 接口。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例二叉树节点实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">PrintableNode</span> &#123;</span><br><span class="line">E element;</span><br><span class="line"></span><br><span class="line">Node&lt;E&gt; left;</span><br><span class="line">Node&lt;E&gt; right;</span><br><span class="line">Node&lt;E&gt; parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E element, Node&lt;E&gt; parent)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.element = element;</span><br><span class="line"><span class="built_in">this</span>.parent = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PrintableNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PrintableNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> element.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在自己的二叉树类中，声明一个<code>printTree</code>方法，调用<code>TreePrinter</code>类的静态方法<code>print</code>，将根结点<code>root</code>传进去即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySerchTree</span>&lt;E&gt; &#123;</span><br><span class="line"><span class="comment">// 根节点</span></span><br><span class="line"><span class="keyword">private</span> Node&lt;E&gt; root; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 若干二叉树的方法...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印二叉树</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printTree</span><span class="params">()</span> &#123;</span><br><span class="line">TreePrinter.print(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】队列</title>
      <link href="/2024/01/23/dsa-06-queue/"/>
      <url>/2024/01/23/dsa-06-queue/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【设计模式】工厂方法模式（Factory Method）</title>
      <link href="/2024/01/22/dp-02-Factory-Method/"/>
      <url>/2024/01/22/dp-02-Factory-Method/</url>
      
        <content type="html"><![CDATA[<p>上一节我们学了<a href="https://zheng-yi-yi.github.io/2024/01/19/dp-01-class-relationships/">类间关系以及UML类图</a>，现在我们来看看工厂方法模式。</p><h1>工厂</h1><p>在面向对象程序设计中，工厂是一个用来创建其他对象的对象。它提供了一种抽象的构造方法，用于实现不同的对象创建方案。工厂对象通常包含一个或多个方法，这些方法用于创建工厂所能生成的不同类别的对象。这些方法可能会接收参数，以指定对象创建的方式，并最终返回创建的对象。</p><p>当对象的创建涉及到复杂的控制过程、配置或其他操作时，工厂对象可以负责将这些细节封装起来，使客户端代码保持简洁，专注于业务逻辑。</p><p>不同的设计模式，如工厂方法模式、抽象工厂模式、生成器模式、单例模式等，都应用了工厂的概念。这些模式通过不同的方式组织和实现工厂，以满足不同的设计需求，提高代码的可维护性和可复用性。</p><h1>工厂方法模式</h1><p>工厂方法模式（Factory method pattern）是一种实现了 <strong>“工厂”</strong> 概念的面向对象设计模式，属于创建型模式。工厂方法模式用于处理<strong>在不指定对象具体类别的情况下创建对象</strong>的问题。</p><blockquote><p>模式意图：<strong>定义一个创建对象的接口，但让实现这个接口的具体类来决定实例化哪些类。工厂方法让类的实例化推迟到子类中进行</strong>。</p></blockquote><h1>类图 | 结构与角色分析</h1><p>先看类图：</p><img src="/2024/01/22/dp-02-Factory-Method/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%B1%BB%E5%9B%BE.png" class="" title="工厂方法类图"><p>下面是角色分析。</p><h2 id="Product">Product</h2><ul><li><code>Product</code>（产品）：抽象类，定义了工厂方法模式中生成的那些实例所持有的属性和方法，但具体的处理则由子类<code>ConcreteProduct</code>角色来决定。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产品：工厂方法所创建的对象的抽象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">  <span class="comment">//可以定义Product的属性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Creator">Creator</h2><ul><li><code>Creator</code>（创建者）：声明工厂方法<code>factoryMethod</code>，负责生成<code>Product</code>。但具体的处理则由子类<code>ConcreteCreator</code>角色来决定。注意！<code>Creator</code>对于<strong>实际负责生成实例</strong>的<code>ConcreteCreator</code>角色一无所知，它唯一知道的就是可以调用<code>Product</code>角色，生成<code>Product</code>实例对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建者，声明工厂方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Creator</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建 Product 的工厂方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> Product对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 示意方法，实现某些功能的方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someOperation</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//通常在这些方法实现中，需要调用工厂方法来获取Product对象</span></span><br><span class="line">      <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> factoryMethod();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里将 <code>factoryMethod</code> 方法定义为抽象方法，因此子类必须实现这个方法来创建真正的实例。</p><h2 id="ConcreteProduct">ConcreteProduct</h2><ul><li><code>ConcreteProduct</code>（具体的产品）：具体产品角色。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体的 Product 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">  <span class="comment">// 实现Product要求的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConcreteCreator">ConcreteCreator</h2><ul><li><code>ConcreteCreator </code>（具体的创建者）：属于具体加工这一方，负责生成具体的产品，返回一个具体的<code>Product</code>对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCreator</span> <span class="keyword">extends</span> <span class="title class_">Creator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 重写工厂方法，返回一个具体的Product对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>举例 | 电视机工厂生产电视机的例子</h1><h2 id="类图">类图</h2><img src="/2024/01/22/dp-02-Factory-Method/%E7%94%B5%E8%A7%86%E6%9C%BA%E5%B7%A5%E5%8E%82%E7%94%9F%E4%BA%A7%E7%94%B5%E8%A7%86%E6%9C%BA%E7%9A%84%E4%BE%8B%E5%AD%90_%E7%B1%BB%E5%9B%BE.png" class="" title="电视机工厂生产电视机的例子_类图"><h2 id="客户端使用">客户端使用</h2><p>我们首先来看客户端的使用效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端代码，使用工厂创建产品并调用其方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建海尔工厂实例</span></span><br><span class="line">        <span class="type">Factory</span> <span class="variable">haierFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HaierFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用工厂创建产品，这里是海尔电视</span></span><br><span class="line">        <span class="type">TV</span> <span class="variable">haierTv</span> <span class="operator">=</span> haierFactory.createProduct();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用产品的方法</span></span><br><span class="line">        haierTv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）海尔工厂正在生产海尔电视机...</span><br><span class="line">（2）已创建“海尔电视机”...</span><br><span class="line">（3）海尔电视机播放中...</span><br></pre></td></tr></table></figure><h2 id="产品角色（Product）">产品角色（Product）</h2><ul><li><code>TV</code>表示工厂方法模式中的抽象产品“电视机”，由抽象类来实现（也可以定义为接口）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TV</span> &#123;  <span class="comment">//角色1：Product </span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象TV类：表示抽象产品（电视机），在该类中仅声明 play 抽象方法，表示电视机在播放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂角色（Creator）">工厂角色（Creator）</h2><ul><li><code>Factory</code>是一个抽象类，声明创建产品对象的抽象方法<code>createProduct</code>，具体处理让子类去实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;  <span class="comment">//角色2：Creator</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电视机工厂生产电视机产品</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> TV <span class="title function_">createProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体产品角色（ConcreteProduct）">具体产品角色（ConcreteProduct）</h2><ul><li><code>HaierTV</code>是产品角色<code>TV</code>的实现类，是工厂方法创建的实际对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HaierTV</span> <span class="keyword">extends</span> <span class="title class_">TV</span> &#123;  <span class="comment">//角色3：ConcreteProduct</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HaierTV</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;（2）已创建“海尔电视机”...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;（3）海尔电视机播放中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体工厂角色（ConcreteCreator）">具体工厂角色（ConcreteCreator）</h2><ul><li><code>HaierFactory</code>是工厂角色<code>Factory</code>的具体实现类，实现了创建产品的方法<code>createProduct</code>，生成具体的产品对象<code>HaierTV</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HaierFactory</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123; <span class="comment">//角色4：ConcreteCreator</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TV <span class="title function_">createProduct</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;（1）海尔工厂正在生产海尔电视机...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HaierTV</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式优点">模式优点</h2><p>工厂方法模式通过将产品的实例化延迟到具体的工厂类，实现了客户端与具体产品的解耦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HaierFactory</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TV <span class="title function_">createProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;（1）海尔工厂正在生产海尔电视机...&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里返回具体的产品实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HaierTV</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端通过调用具体工厂的<code>createProduct</code>方法来获取产品实例，而无需关心具体产品的创建过程。</p><p>新增产品时，只需新增一个具体工厂类继承自抽象工厂，重写抽象工厂中的抽象方法，这样可以在不修改已有具体工厂类的情况下引进新的产品，符合开闭原则，降低了耦合度。</p><blockquote><p>开闭原则：对修改封闭，对扩展开放。</p></blockquote><h2 id="新增产品">新增产品</h2><p>比如现在，我们引入新的产品：索尼电视机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SonyTV</span> <span class="keyword">extends</span> <span class="title class_">TV</span> &#123;  <span class="comment">//角色：ConcreteProduct</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SonyTV</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;（2）已创建“索尼电视机”...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;（3）索尼电视机播放中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及具体的工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SonyFactory</span> <span class="keyword">extends</span> <span class="title class_">Factory</span> &#123; <span class="comment">//角色：ConcreteCreator</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TV <span class="title function_">createProduct</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;（1）索尼工厂正在生产索尼电视机...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SonyTV</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们来客户端中测试一把：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123; <span class="comment">//客户端</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Factory</span> <span class="variable">haierFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HaierFactory</span>();</span><br><span class="line"><span class="type">TV</span> <span class="variable">haierTv</span> <span class="operator">=</span> haierFactory.createProduct();</span><br><span class="line">haierTv.play();</span><br><span class="line">System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line"><span class="type">Factory</span> <span class="variable">sonyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SonyFactory</span>();</span><br><span class="line"><span class="type">TV</span> <span class="variable">sonyTv</span> <span class="operator">=</span> sonyFactory.createProduct();</span><br><span class="line">sonyTv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（1）海尔工厂正在生产海尔电视机...</span><br><span class="line">（2）已创建“海尔电视机”...</span><br><span class="line">（3）海尔电视机播放中...</span><br><span class="line">----------</span><br><span class="line">（1）索尼工厂正在生产索尼电视机...</span><br><span class="line">（2）已创建“索尼电视机”...</span><br><span class="line">（3）索尼电视机播放中...</span><br></pre></td></tr></table></figure><p>类图如下：</p><img src="/2024/01/22/dp-02-Factory-Method/%E6%96%B0%E5%A2%9E%E7%B4%A2%E5%B0%BC%E7%94%B5%E8%A7%86%E6%9C%BA.png" class="" title="新增索尼电视机"><h1>总结</h1><blockquote><p>“在工厂方法模式中，父类决定实例的生成方式，但并不决定所要生成的具体的类，具体的处理全部交给子类负责。将生成实例的框架（framework）和实际负责生成实例的类进行解耦”。</p></blockquote><p>我们总结一下，对于工厂方法模式来说，它就是封装一个创建对象的抽象类（或者说接口），由该抽象类的子类来决定实例化哪一个产品类，因此我们说工厂方法模式将类的实例化延迟到子类中完成。产品类可以有很多个，作为客户端（调用者）来说，只需调用工厂方法返回产品即可（我要什么你就给我什么）。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工厂方法模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】树与二叉树</title>
      <link href="/2024/01/21/dsa-05-tree/"/>
      <url>/2024/01/21/dsa-05-tree/</url>
      
        <content type="html"><![CDATA[<h1>树</h1><h2 id="概述">概述</h2><p>树（tree）是一种抽象数据类型（ADT），或者说是一种用于模拟具有树状结构性质的非线性数据结构。</p><p>它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合，之所以称为树，是因为它看起来像“倒挂”的树，根在上，叶子朝下：</p><img src="/2024/01/21/dsa-05-tree/tree.png" class="" title="tree"><p>树的特点如下：</p><ul><li><p>没有父节点的节点称为根节点（root）；</p></li><li><p>每个节点都含有有限个子节点，或者没有子节点；</p></li><li><p>每一个非根节点有且只有一个父节点；</p></li><li><p>除了根节点外，每个子节点可以分为多个不相交的子树；</p></li><li><p>树里面没有环路(cycle)</p></li></ul><h2 id="树的术语">树的术语</h2><img src="/2024/01/21/dsa-05-tree/tree-jieshao.png" class="" title="tree-jieshao"><h3 id="节点的度">节点的度</h3><p><strong>子树的个数</strong>就是节点的度。</p><h3 id="树的度">树的度</h3><p><strong>所有节点度中的最大值</strong>称为树的度。</p><h3 id="叶子节点">叶子节点</h3><p>叶子节点（leaf）也称为终端节点，<strong>度为0的节点</strong>就是叶子节点。</p><h3 id="分支节点">分支节点</h3><p>也称为非终端节点，<strong>度不为0的节点</strong>就是分支节点。</p><h3 id="层次（层数）">层次（层数）</h3><p>层数（level）：根节点在第 1 层，根节点的子节点在第 2 层，以此类推</p><h3 id="父节点">父节点</h3><p>若一个节点含有子节点，则这个节点称为其子节点的父节点；</p><h3 id="子节点">子节点</h3><p>一个节点含有的子树的根节点，称为该节点的子节点；</p><h3 id="兄弟节点">兄弟节点</h3><p>具有相同父节点的节点互称为兄弟节点；</p><h3 id="节点的深度">节点的深度</h3><p>节点的<strong>深度</strong>（depth）指的是<strong>从根节点到当前节点的唯一路径上的节点总数</strong>。</p><h3 id="节点的高度">节点的高度</h3><p>节点的<strong>高度</strong>（height）指的是<strong>从当前节点到最远叶子节点的路径上的节点总数</strong>。</p><h3 id="树的深度与高度">树的深度与高度</h3><p>树的深度：所有节点深度中的最大值</p><p>树的高度：所有节点高度中的最大值</p><blockquote><p><strong>实际上，树的深度就等于树的高度</strong></p></blockquote><h3 id="堂兄弟节点">堂兄弟节点</h3><p>父节点在同一层的节点互为堂兄弟；</p><h3 id="节点的祖先">节点的祖先</h3><p>从根到该节点所经分支上的所有节点；</p><h3 id="子孙">子孙</h3><p>以某节点为根的子树中任一节点都称为该节点的子孙。</p><h3 id="森林">森林</h3><p>由m（m&gt;=0）棵互不相交的树的集合称为森林；</p><hr><h2 id="分类">分类</h2><p>我们可以对树进行不同的分类。以下是一些常见的树的分类：</p><ol><li><p><strong>有序/无序：</strong></p><ul><li>无序树：树中任意节点的子节点之间没有顺序关系，也称为自由树。</li><li>有序树/搜索树/查找树：树中任意节点的子节点之间有顺序关系，这种树称为有序树。比如二叉搜索树。</li></ul></li><li><p><strong>平衡/不平衡：</strong></p><ul><li><p>平衡树：确保树的高度相对较小，以提高插入、删除和查找的效率。</p><ul><li>绝对平衡树：所有叶节点在同一层。</li><li>非绝对平衡树。</li></ul></li><li><p>不平衡树：树的节点分布不均匀，可能导致不同操作的效率下降。</p></li></ul></li><li><p><strong>节点的分叉情况：</strong></p><ul><li><p>等叉树：每个节点的键值个数和子节点个数都相同。</p></li><li><p>二叉树：每个节点最多含有两个子树。</p><ul><li>完全二叉树：除最底层外，其他层的节点数目均达到最大，且最底层从左到右紧密排列。</li><li>满二叉树：所有叶节点都在最底层的完全二叉树。</li><li>平衡二叉树（AVL树）：任何节点的两棵子树的高度差不大于1的二叉树。</li><li>排序二叉树（二叉搜索树）：有序的二叉树，左子树的所有节点值小于根节点，右子树的所有节点值大于根节点。</li><li>霍夫曼树：带权路径最短的二叉树，也称为最优二叉树。</li></ul></li><li><p>多叉树：每个节点可以有多于两个的子节点。</p><ul><li>不等叉树：每个节点的键值个数和子节点个数不一定相同。</li><li>B树：对不等叉树的节点键值数和插入、删除逻辑添加一些特殊的要求，以达到绝对平衡的效果。</li></ul></li></ul></li></ol><h1>二叉树</h1><p>什么是二叉树？</p><p>如果一棵树，它每个节点最多只有两个分支，那么它就是一颗二叉树。也就是说，二叉树不存在分支度大于2的节点（最多拥有两颗子树）。通常分支被称作 <strong>“左子树”</strong> 或 <strong>“右子树”</strong> 。</p><img src="/2024/01/21/dsa-05-tree/the-5-Binary-trees-of-size-3.png" class="" title="the-5-Binary-trees-of-size-3"><blockquote><p>二叉树的分支具有左右次序，不能随意颠倒（颠倒后就是另一颗二叉树）。</p></blockquote><p>二叉树的性质如下：</p><img src="/2024/01/21/dsa-05-tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8.png" class="" title="二叉树的性质"><h1>真二叉树</h1><p>如果一颗树，它所有节点的度要么为0，要么为2，那么这棵树就是真二叉树。</p><img src="/2024/01/21/dsa-05-tree/%E7%9C%9F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A4%E6%96%AD.png" class="" title="真二叉树的判断"><h1>满二叉树</h1><p>二叉树的种类有很多，我们先来看<strong>满二叉树</strong>。</p><p>如果一棵二叉树只有度为0的节点和度为2的节点，并且度为0的节点在同一层上，则这棵二叉树为满二叉树。</p><blockquote><p><strong>满二叉树：最后一层节点的度都为 0，其他节点的度都为 2</strong></p></blockquote><p>我们发现，一颗满二叉树，如果它的深度为k，则它有(2^k)-1个节点。</p><img src="/2024/01/21/dsa-05-tree/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" class="" title="满二叉树"><p>比如上面这个就是一颗满二叉树，它的深度为3，那么它一共有(2^3)-1个节点，也就是7个。</p><p>实际上，满二叉树的特点就是，每一层节点数都是满的，每一层上的节点都达到最大节点数。</p><blockquote><p>满二叉树，在国外又称之为“完美二叉树”（Perfect Binary Tree）。</p></blockquote><p>满二叉树有什么性质？通过观察我们发现：</p><img src="/2024/01/21/dsa-05-tree/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8.png" class="" title="满二叉树的性质"><blockquote><p>在同样高度的二叉树中，满二叉树的叶子节点数量最多、总节点数量最多。这是显而易见的。</p></blockquote><h1>完全二叉树</h1><p>那什么是完全二叉树？</p><p>实际上，在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且<strong>最下面一层的节点都集中在该层最左边的若干位置</strong>。</p><blockquote><p>也就是说，在一棵二叉树中，如果除了最后一层之外，其余层都是满的，并且最后一层要么是满的，要么在右边缺少连续若干节点，则此二叉树就是完全二叉树。</p></blockquote><img src="/2024/01/21/dsa-05-tree/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A4%E6%96%AD.png" class="" title="完全二叉树的判断"><blockquote><p>堆就是一颗完全二叉树，同时保证父子节点的顺序关系。</p></blockquote><p>深度为k的完全二叉树，至少有 2^{k-1} 个节点，最多有 2^(k)-1 个节点。</p><p>若最底层为第 h 层（h从1开始），则该层包含 1 ~ 2^(h-1) 个节点。</p><blockquote><p><strong>满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树</strong>。</p></blockquote><p>如果一颗完全二叉树的总节点数量为 <code>n</code>，那么它的：</p><ul><li>高度：<code>floor(log2n) + 1</code></li><li>叶子节点个数 <code>n0 = floor( (n+1)/2 )</code></li><li>分支节点个数 <code>n2+n1 = floor(n/2)</code></li></ul><img src="/2024/01/21/dsa-05-tree/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8.png" class="" title="完全二叉树的性质"><h1>二叉搜索树</h1><p>二叉搜索树（Binary Search Tree，简称BST），是指一棵空树或者具有下列性质的二叉树：</p><ul><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉搜索树；</li></ul><blockquote><p>二叉搜索树也称为二叉查找树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree）</p></blockquote><p>看下图：</p><img src="/2024/01/21/dsa-05-tree/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%A4%BA%E4%BE%8B.png" class="" title="二叉搜索树示例"><p>二叉查找树相比于其他二叉树的优势在于查找、插入的时间复杂度较低，为 <code>O(log n)</code>。</p><h1>平衡二叉搜索树（AVL树）</h1><p>平衡二叉搜索树，又称为AVL（Adelson-Velsky and Landis）树，其定义如下：</p><p>平衡二叉搜索树是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><blockquote><p>“在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。”</p></blockquote><p>AVL树的查找、插入和删除在平均和最坏情况下的时间复杂度都是 <code>O(log n)</code>。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。</p><img src="/2024/01/21/dsa-05-tree/AVL%E6%A0%91.png" class="" title="AVL树"><blockquote><p>“节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。”</p></blockquote><h1>二叉树的存储方式</h1><p>二叉树可以链式存储，也可以顺序存储。</p><p>链式存储，就用对象引用的方式，将各个节点串联起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line"></span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图所示：</p><img src="/2024/01/21/dsa-05-tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.png" class="" title="二叉树的链式存储"><p>而对于数组存储二叉树，如果父节点的数组下标是 <code>i</code>，那么它的左孩子就是 <code>i * 2 + 1</code>，右孩子就是 <code>i * 2 + 2</code>。</p><p>如图所示：</p><img src="/2024/01/21/dsa-05-tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8.png" class="" title="二叉树的数组存储"><h1>二叉树的打印</h1><p>这里我提供了一个可以打印二叉树的工具类，详情见下面这个文章：</p><ul><li><a href="https://zheng-yi-yi.github.io/2024/01/23/dsa-07-printTreeTool/">【工具类】打印二叉树</a></li></ul><p>打印效果如下：</p><p><img src="/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%88%E6%9E%9C.png" alt="二叉树打印工具的使用效果"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】栈</title>
      <link href="/2024/01/21/dsa-04-Stack/"/>
      <url>/2024/01/21/dsa-04-Stack/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Java集合框架】概述</title>
      <link href="/2024/01/21/JCF-01-overview/"/>
      <url>/2024/01/21/JCF-01-overview/</url>
      
        <content type="html"><![CDATA[<h1>Java集合框架</h1><p>Java集合框架（<em>Java collections framework</em>）是包含一系列实现可重复使用集合的数据结构的类别和接口集合。</p><p>哈哈哈哈听起来有点杂，我们来捋一捋。</p><p>实际上就是<code>Java</code>提供了一个强大的集合框架，用于处理一系列对象。也就是说，集合是一种通用的容器，是对象的组合，集合框架提供了一种统一的方式来表示和操作各种集合，无需重复造轮子，减少了编程工作。提供了高性能的数据结构和算法实现，只需学习一组通用的集合API，减低学习难度。</p><blockquote><p>集合框架的设计旨在使开发人员能够更轻松地管理和操作数据，同时提供了高性能和可扩展性。</p></blockquote><h1>集合接口</h1><p><code>Java</code>集合框架定义了一系列<strong>容器接口</strong>，<strong>主要分为两个层次，分别是<code>Collection</code>接口和<code>Map</code>接口</strong>，集合接口用于规范容器的行为以及提供统一的设计：</p><img src="/2024/01/21/JCF-01-overview/Collection-Map.png" class="" title="Collection-Map"><p>记录：</p><ul><li><code>Collection</code> ：是大部分集合框架的根接口，表示一组对象。它定义了基本的集合操作，如添加、删除、遍历等。<ul><li><code>Set</code>：继承自<code>Collection</code>，表示不包含重复元素的集合。它没有提供额外的方法，只是保证不包含重复元素。<ul><li><code>SortedSet</code>：继承自Set，对元素进行排序存储。提供了一些按比较器排序或自然排序的方法。<ul><li><code>NavigableSet</code>：继承自<code>SortedSet</code>，定义了一些导航方法，如获取最小、最大元素等。</li></ul></li></ul></li><li><code>List</code>：继承自<code>Collection</code>，表示有序的集合，允许包含重复元素。提供了根据索引访问元素的方法。</li><li><code>Queue</code>：继承自<code>Collection</code>，表示队列数据结构，按照先进先出（FIFO）的原则处理元素。<ul><li><code>BlockingQueue</code>：继承自<code>Queue</code>，增加了支持阻塞操作的方法，用于多线程环境中的生产者-消费者模型。<ul><li><code>TransferQueue</code>：基础自<code>BlockingQueue</code>，它提供了更强大的元素传输机制。</li></ul></li><li><code>Deque</code>：继承自<code>Queue</code>，表示双端队列，可以在两端插入和删除元素。<ul><li><code>BlockingDeque</code>：继承自<code>Deque</code>和<code>BlockingQueue</code>，支持阻塞操作的双端队列。</li></ul></li></ul></li></ul></li><li><code>Map</code>：表示键值对的集合，每个键关联一个值。<code>Map</code>不是<code>Collection</code>的子接口。<ul><li><code>SortedMap</code>：继承自<code>Map</code>，按照比较器或键的自然顺序对键进行排序。<ul><li><code>NavigableMap</code>：继承自<code>SortedMap</code>，提供了导航方法，如获取比指定键大或小的键。</li></ul></li><li><code>ConcurrentMap</code>：继承自<code>Map</code>，支持并发访问，定义了一些原子性的操作。<ul><li><code>ConcurrentNavigableMap</code>：继承自<code>ConcurrentMap</code>和<code>NavigableMap</code>，表示支持并发访问和导航操作的映射。</li></ul></li></ul></li></ul><blockquote><p>这里没有写<code>Stack</code>，是因为<code>Stack</code>的功能已被JDK 1.6引入的<code>Deque</code>取代。</p></blockquote><h1>集合实现</h1><p>上述接口的常见实现类见下表，我们这个系列会逐一学习这些实现类的基本用法。</p><table><thead><tr><th style="text-align:center">Interface</th><th style="text-align:center">Hash Table<br />（哈希表）</th><th style="text-align:center">Resizable Array<br />（可变数组）</th><th style="text-align:center">Balanced Tree<br />（平衡树）</th><th style="text-align:center">Linked List<br />（链表）</th><th style="text-align:center">Hash Table + Linked List</th></tr></thead><tbody><tr><td style="text-align:center"><code>Set</code></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html"><code>HashSet</code></a></td><td style="text-align:center"></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html"><code>TreeSet</code></a></td><td style="text-align:center"></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashSet.html"><code>LinkedHashSet</code></a></td></tr><tr><td style="text-align:center"><code>List</code></td><td style="text-align:center"></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html"><code>ArrayList</code></a></td><td style="text-align:center"></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html"><code>LinkedList</code></a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>Deque</code></td><td style="text-align:center"></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html"><code>ArrayDeque</code></a></td><td style="text-align:center"></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html"><code>LinkedList</code></a></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>Map</code></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html"><code>HashMap</code></a></td><td style="text-align:center"></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html"><code>TreeMap</code></a></td><td style="text-align:center"></td><td style="text-align:center"><a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html"><code>LinkedHashMap</code></a></td></tr></tbody></table><h1>并发集合</h1><p>在多线程编程中，对集合进行操作需要特别小心以避免并发问题。Java提供了丰富的并发编程支持，其中包括了许多<strong>并发友好的集合接口和实现</strong>。</p><ul><li><code>BlockingQueue</code>：<ul><li>扩展了普通队列的功能，提供了在多线程环境下进行元素传输的能力。它包含了一些阻塞操作，如<code>put</code>和<code>take</code>，用于在队列为空或已满时进行等待。</li><li>实现：<ul><li><code>LinkedBlockingQueue</code>：基于链表实现，支持有界和无界的队列。</li><li><code>ArrayBlockingQueue</code>：基于数组实现，支持有界的队列。</li><li><code>PriorityBlockingQueue</code>：无界队列，按照元素的优先级进行排序。</li><li><code>DelayQueue</code>：用于按照元素的延迟时间进行排序的无界队列。</li><li><code>SynchronousQueue</code>：一个不存储元素的队列，每个插入操作必须等待一个相应的删除操作，反之亦然。</li></ul></li></ul></li><li><code>TransferQueue</code>：<ul><li>是<code>BlockingQueue</code>的子接口，引入了更高级别的元素传输机制。它提供了<code>transfer</code>方法，可以立即传输元素给等待的消费者。</li><li>实现：<ul><li><code>LinkedTransferQueue</code>：TransferQueue的一个实现，提供了更高级别的元素传输机制。</li></ul></li></ul></li><li><code>BlockingDeque</code>：<ul><li>双端队列的接口，它扩展了<code>BlockingQueue</code>和<code>Deque</code>的功能，提供了在两端插入和删除元素的能力。</li><li>实现：<ul><li><code>LinkedBlockingDeque</code>：基于链表实现，支持有界和无界的双端队列。</li></ul></li></ul></li><li><code>ConcurrentMap</code>：<ul><li>扩展了普通的<code>Map</code>接口，提供了对并发访问的支持。它定义了一些原子性的操作，如<code>putIfAbsent</code>和<code>replace</code>。</li><li>实现：<ul><li><code>ConcurrentHashMap</code>：采用分段锁的机制，提高并发性能。</li></ul></li></ul></li><li><code>ConcurrentNavigableMap</code>：<ul><li><code>ConcurrentMap</code>的子接口，它扩展了<code>NavigableMap</code>接口，提供了对并发访问的支持以及导航特性。</li><li>实现：<ul><li><code>ConcurrentSkipListMap</code>：基于跳表（<code>SkipList</code>）实现，并支持并发访问和导航特性。</li></ul></li></ul></li></ul><h1>泛型</h1><p>Java的泛型是一种方便的语法糖，通过在编译阶段进行字符串替换来实现。在JDK 1.5及以后的版本中引入了泛型机制，使得容器可以容纳任何类型的对象。泛型的优势在于在编译时捕获类型错误，避免了在运行时发生的类型转换错误。相比于JDK 1.4及之前的显式类型转换，使用泛型可以使代码更简洁、可读性更高，并提高了代码的安全性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 1.4 or before</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Monday&quot;</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tuesday&quot;</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Wednesday&quot;</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">weekday</span> <span class="operator">=</span> (String)list.get(i); <span class="comment">// 显式类型转换</span></span><br><span class="line">    System.out.println(weekday.toUpperCase());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK 1.5 or later</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">// 参数化类型</span></span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Monday&quot;</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tuesday&quot;</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Wednesday&quot;</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">weekday</span> <span class="operator">=</span> list.get(i); <span class="comment">// 隐式类型转换，编译器自动完成</span></span><br><span class="line">    System.out.println(weekday.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java集合框架 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】链表</title>
      <link href="/2024/01/21/dsa-03-Linked-list/"/>
      <url>/2024/01/21/dsa-03-Linked-list/</url>
      
        <content type="html"><![CDATA[<h1>概念</h1><p>链表（Linked list）是一种线性表。由一系列节点对象组成，每个节点包含数据元素和一个指向下一个节点的引用，也就是说，各个节点通过“引用”相连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表节点类：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> elem;<span class="comment">// 节点的值</span></span><br><span class="line">    ListNode next;<span class="comment">// 指向下一个节点的引用（也称为指针域）</span></span><br><span class="line">    </span><br><span class="line">    ListNode(<span class="type">int</span> element) &#123;<span class="comment">// 构造器</span></span><br><span class="line">        elem = element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>“引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点。因此，链表的设计使得各个节点可以分散存储在内存各处，它们的内存地址无须连续。”</p></blockquote><p>链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理，同时，也失去了快速随机存取的优点（数组），同时增大了内存开销（存储下一个节点）。</p><h1>链表类型</h1><p>常见链表类型有三种，分别是单链表，环形链表和双向链表。对比如下：</p><table><thead><tr><th>特性</th><th>单向链表</th><th>环形链表</th><th>双向链表</th></tr></thead><tbody><tr><td>简介</td><td>简称<strong>单链表</strong>，是一种常规链表，其节点包含值和指向下一节点的引用两项数据，头节点指向第一个实际存储数据的节点，尾节点指向<code>null</code>。</td><td>首尾相接，将单链表的尾节点指向头节点就得到了一个<strong>环形链表</strong>。在环形链表中，任意节点都可以视为头节点。</td><td>与单链表相比，<strong>双向链表</strong>记录了两个方向的引用，也就是前驱结点<code>prev</code>和后继节点<code>next</code>，因此更加灵活，可以朝两个方向遍历链表。</td></tr><tr><td>节点结构</td><td>数据 + 下一节点的指针</td><td>数据 + 下一节点的指针</td><td>数据 + 下一节点的指针 + 前一节点的指针</td></tr><tr><td>遍历特点</td><td>单向遍历</td><td>循环遍历</td><td>双向遍历（前向和后向）</td></tr></tbody></table><img src="/2024/01/21/dsa-03-Linked-list/linklist-vs.png" class="" title="linklist-vs"><h1>头节点</h1><p>在使用单链表的时候，我们通常会使用一个头节点（<code>head</code>）。</p><p><strong>该头节点不存储数据，而是指向第一个实际存储数据的节点</strong>。</p><blockquote><p>尾节点就是最后一个节点，该节点指向的下一个节点为<code>null</code>。</p></blockquote><p>为什么需要头节点？</p><p>使用头节点，可以简化对链表的操作，提供一个固定的起点。如果没有头节点，我们在对链表进行插入、删除等操作时需要考虑处理第一个节点的特殊情况。头节点的存在使得链表的操作更加一致，使代码更加简洁和统一。</p><h1>单链表的使用效果</h1><p>下面，我们来编写一个单链表 <code>LinkedList</code>，实现之后可以这样使用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个链表实例</span></span><br><span class="line">        <span class="type">LinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向链表的尾部添加6个元素</span></span><br><span class="line">        linkedList.addLast(<span class="number">10</span>);</span><br><span class="line">        linkedList.addLast(<span class="number">20</span>);</span><br><span class="line">        linkedList.addLast(<span class="number">30</span>);</span><br><span class="line">        linkedList.addLast(<span class="number">40</span>);</span><br><span class="line">        linkedList.addLast(<span class="number">50</span>);</span><br><span class="line">        linkedList.addLast(<span class="number">60</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印链表</span></span><br><span class="line">        System.out.println(<span class="string">&quot;(1) 初始化后，当前链表为：&quot;</span> + linkedList.printList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出链表的大小</span></span><br><span class="line">        System.out.println(<span class="string">&quot;(2) 链表的大小：&quot;</span> + linkedList.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在指定位置插入元素</span></span><br><span class="line">        linkedList.add(<span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;(3) 在索引为1的位置插入元素15后，链表：&quot;</span> + linkedList.printList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在指定位置插入元素</span></span><br><span class="line">        linkedList.addFirst(<span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;(4) 在链表的头部添加一个元素100，链表：&quot;</span> + linkedList.printList());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断链表是否含有指定元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;(5) 判断链表是否包含元素15：&quot;</span> + linkedList.contains(<span class="number">15</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置链表中指定位置的元素值</span></span><br><span class="line">        linkedList.set(<span class="number">5</span>, <span class="number">15</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;(6) 将链表中索引为5的元素修改值为15，链表：&quot;</span> + linkedList.printList());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除链表中指定索引处的元素</span></span><br><span class="line">        linkedList.remove(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;(7) 将链表中索引为1的元素移除，链表：&quot;</span> + linkedList.printList());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除链表中第一个出现的指定元素</span></span><br><span class="line">        linkedList.removeElement(<span class="number">50</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;(8) 删除值为50的节点后，链表：&quot;</span> + linkedList.printList());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回链表中指定位置的元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;(9) 链表中索引为3的节点的值为：&quot;</span> + linkedList.get(<span class="number">3</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找链表中指定元素从前往后第一次出现的索引</span></span><br><span class="line">        System.out.println(<span class="string">&quot;(10) 链表中第一次出现值为15的节点，其索引为：&quot;</span> + linkedList.indexOf(<span class="number">15</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找链表中指定元素最后一次出现的索引</span></span><br><span class="line">        System.out.println(<span class="string">&quot;(11) 链表中最后一次出现值为15的节点，其索引为：&quot;</span> + linkedList.lastIndexOf(<span class="number">15</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(1) 初始化后，当前链表为：[10 → 20 → 30 → 40 → 50 → 60]</span><br><span class="line">(2) 链表的大小：6</span><br><span class="line">(3) 在索引为1的位置插入元素15后，链表：[10 → 15 → 20 → 30 → 40 → 50 → 60]</span><br><span class="line">(4) 在链表的头部添加一个元素100，链表：[100 → 10 → 15 → 20 → 30 → 40 → 50 → 60]</span><br><span class="line">(5) 判断链表是否包含元素15：true</span><br><span class="line">(6) 将链表中索引为5的元素修改值为15，链表：[100 → 10 → 15 → 20 → 30 → 15 → 50 → 60]</span><br><span class="line">(7) 将链表中索引为1的元素移除，链表：[100 → 15 → 20 → 30 → 15 → 50 → 60]</span><br><span class="line">(8) 删除值为50的节点后，链表：[100 → 15 → 20 → 30 → 15 → 60]</span><br><span class="line">(9) 链表中索引为3的节点的值为：30</span><br><span class="line">(10) 链表中第一次出现值为15的节点，其索引为：1</span><br><span class="line">(11) 链表中最后一次出现值为15的节点，其索引为：4</span><br></pre></td></tr></table></figure><h1>实现一个单链表</h1><img src="/2024/01/21/dsa-03-Linked-list/linklist.png" class="" title="linklist"><h2 id="Node">Node</h2><p>在链表中，其组成元素都是节点（<code>Node</code>）对象。并且每个节点都包含两项数据：</p><ol><li>节点的“值”（<code>elem</code>）</li><li>指向下一个节点的“引用”（<code>next</code>）</li></ol><p>我们来写一下这个<code>Node</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为Node的类，表示链表中的节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有属性，表示节点中的元素值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> elem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有属性，表示当前节点的下一个节点（也称为指针域）</span></span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法，接收一个整数元素值和下一个节点作为参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> element, Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elem = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造方法，创建一个元素值为0，下一个节点为null的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置元素值的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setElem</span><span class="params">(<span class="type">int</span> element)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elem = element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取元素值的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getElem</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.elem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置下一个节点的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个节点的方法</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类说明：</span></span><br><span class="line"><span class="comment">// 1. Node类表示链表中的节点，每个节点包含一个元素值和对下一个节点的引用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 构造方法 Node(int element, Node next)：</span></span><br><span class="line"><span class="comment">//    用于创建具有给定元素值和下一个节点引用的节点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 默认构造方法 Node()：</span></span><br><span class="line"><span class="comment">//    创建一个元素值为0，下一个节点为null的节点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. setElem(int element)：</span></span><br><span class="line"><span class="comment">//    设置节点的元素值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. getElem()：</span></span><br><span class="line"><span class="comment">//    获取节点的元素值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. setNext(Node next)：</span></span><br><span class="line"><span class="comment">//    设置节点的下一个节点引用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. getNext()：</span></span><br><span class="line"><span class="comment">//    获取节点的下一个节点引用。</span></span><br></pre></td></tr></table></figure><h2 id="LinkedList">LinkedList</h2><p>这里我们定义一个类，用于表示一个链表类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node head; <span class="comment">// 头节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(); <span class="comment">// 创建头节点，数据域和指针域均为空</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就成功地初始化了一个单链表，可以在这个基础上进行后续的节点插入、删除等操作。</p><h2 id="size">size</h2><p><code>size()</code> 方法用于获取链表的大小，即链表中包含的元素数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取链表的大小，即链表中包含的元素数量。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 链表的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化计数器为0，用于记录链表的大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从头节点开始，遍历链表，直到遍历到末尾节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head.getNext();</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        current = current.getNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回链表的大小，即元素的数量</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isEmpty">isEmpty</h2><p>判断链表是否为空，可以有两种策略：</p><ul><li>策略一：使用<code>size()</code>方法，判断链表存储的元素数量是否为0。</li><li>策略二：判断头节点的指针域是否为<code>null</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查链表是否为空。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果链表为空，则返回true；否则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 判断链表是否为空，通过检查头节点的下一个节点是否为null来判断</span></span><br><span class="line">    <span class="keyword">return</span> head.getNext() == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="clear">clear</h2><p><code>clear()</code>方法用于清空链表，移除所有节点。实际就是将头节点的下一个节点设为<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空链表，移除所有节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 将头节点的下一个节点设为null，即移除所有节点</span></span><br><span class="line">    head.setNext(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="contains">contains</h2><p><code>contains(int element)</code>方法用于判断链表是否含有指定元素<code>element</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断链表是否含有指定元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要判断的元素。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 如果链表包含指定元素，false 如果链表不包含指定元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="comment">// 从头节点开始遍历链表，查找是否包含指定元素</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head.getNext();</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.getElem() == element) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 找到指定元素，返回true</span></span><br><span class="line">        &#125;</span><br><span class="line">        current = current.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 链表中不包含指定元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set">set</h2><p><code>set(int index, int element)</code>方法用于设置链表中指定位置的元素值，并且返回原元素的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置链表中指定位置的元素值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index   要设置元素的位置，从0开始计数。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要设置的元素值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 被替换的原元素的值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果指定位置超出链表范围。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> element)</span> <span class="keyword">throws</span> IndexOutOfBoundsException &#123;</span><br><span class="line">    <span class="comment">// 检查指定位置是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;指定位置超出链表范围&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到指定位置的节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head.getNext();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        current = current.getNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原元素的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldValue</span> <span class="operator">=</span> current.getElem();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的元素值</span></span><br><span class="line">    current.setElem(element);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="printList">printList</h2><p><code>printList()</code>方法用于打印链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印链表，每个节点之间用 &quot;→&quot; 进行连接。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 表示链表的字符串。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">printList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    result.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表，将每个节点的元素拼接到字符串中</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head.getNext();</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        result.append(current.getElem());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否为最后一个节点，如果不是，则添加 &quot;→&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (current.getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">            result.append(<span class="string">&quot; → &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        current = current.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    result.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入元素">插入元素</h2><h3 id="add">add</h3><p><code>add(index, element)</code>方法用于向在<strong>指定位置</strong>插入新元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向链表的指定位置插入元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index   插入的位置，从0开始计数。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要插入的元素。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果插入位置超出链表范围。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> element)</span> <span class="keyword">throws</span> IndexOutOfBoundsException &#123;</span><br><span class="line">    <span class="comment">// 创建新节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(element, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查插入位置是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;插入位置超出链表范围&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到插入位置的前一个节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        current = current.getNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新节点</span></span><br><span class="line">    newNode.setNext(current.getNext());</span><br><span class="line">    current.setNext(newNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>Node current = head;</code> 用于初始化一个临时节点(<code>current</code>)，并将其设置为链表头节点(<code>head</code>)，从头节点开始遍历链表。循环的次数为插入位置(<code>index</code>)，每次迭代将<code>current</code>移动到下一个节点，最终将<code>current</code>移动到插入位置的前一个节点。</p><p>最后两行代码，用于将新节点的下一个节点设置为当前节点的下一个节点，然后将当前节点的下一个节点设置为新节点。这样就成功地在指定位置插入了新节点。</p></blockquote><h3 id="addLast">addLast</h3><p><code>addLast(int element)</code>方法，用于向链表的尾部添加一个新的元素，插入的新元素总是位于链表的末尾（也就是指针域为<code>null</code>的节点），我们称为尾插法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在链表的末尾添加一个新节点，该节点包含指定的元素值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要添加的元素值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> element)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的节点，该节点包含指定的元素值，并其下一个节点引用为null</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(element, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从头节点开始，找到链表的末尾节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (tail.getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">        tail = tail.getNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新节点的添加到末尾节点的下一个节点引用，从而将新节点添加到链表的末尾</span></span><br><span class="line">    tail.setNext(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addFirst">addFirst</h3><p><code>addFirst()</code>方法用于向链表的头部添加一个新的元素，插入的新元素总是位于链表的头部（也就是头节点指向的节点），我们称之为头插法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在链表的开头添加一个新节点，该节点包含指定的元素值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要添加的元素值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> element)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的节点，该节点包含指定的元素值，并其下一个节点引用为null</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(element, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新节点的下一个节点引用设置为当前头节点的下一个节点</span></span><br><span class="line">    node.setNext(head.getNext());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将头节点的下一个节点引用更新为新节点，从而将新节点添加到链表的开头</span></span><br><span class="line">    head.setNext(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在链表头部插入元素的步骤如下：</p><ol><li>根据新元素的值，构建一枚新节点</li><li>将新节点指针域置为原先链表中头节点指向的节点</li><li>最后，将头节点指向新节点</li></ol><h2 id="移除元素">移除元素</h2><h3 id="remove">remove</h3><p><code>remove(int index)</code>方法用于删除链表中指定位置<code>index</code>的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除链表中指定位置的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要删除的位置，从0开始计数。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 被删除的元素的值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果删除位置超出链表范围。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> <span class="keyword">throws</span> IndexOutOfBoundsException &#123;</span><br><span class="line">    <span class="comment">// 检查删除位置是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;删除位置超出链表范围&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到删除位置的前一个节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        current = current.getNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取要删除的节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">removedNode</span> <span class="operator">=</span> current.getNext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将前一个节点的next指向被删除节点的next，实现删除</span></span><br><span class="line">    current.setNext(removedNode.getNext());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回被删除节点的值</span></span><br><span class="line">    <span class="keyword">return</span> removedNode.getElem();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="removeElement">removeElement</h3><p><code>removeElement(int element)</code>方法用于删除链表中第一个出现的指定元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除链表中第一个出现的指定元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要删除的元素。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 如果成功删除了元素，false 如果链表中不包含该元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span> element)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到包含指定元素的节点的前一个节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (current.getNext() != <span class="literal">null</span> &amp;&amp; current.getNext().getElem() != element) &#123;</span><br><span class="line">        current = current.getNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果找到了节点，进行删除操作</span></span><br><span class="line">    <span class="keyword">if</span> (current.getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">        current.setNext(current.getNext().getNext());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 成功删除元素</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 链表中不包含该元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="removeFirst">removeFirst</h3><p><code>removeFirst()</code>方法用于删除并返回链表中的第一个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除并返回链表中的第一个元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 被删除的第一个元素的值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 如果链表为空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeFirst</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException &#123;</span><br><span class="line">    <span class="comment">// 检查链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第一个节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">firstNode</span> <span class="operator">=</span> head.getNext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将头节点的next指向第一个节点的next，实现删除</span></span><br><span class="line">    head.setNext(firstNode.getNext());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回被删除节点的值</span></span><br><span class="line">    <span class="keyword">return</span> firstNode.getElem();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="removeLast">removeLast</h3><p><code>removeLast()</code>方法用于删除并返回链表中的最后一个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除并返回链表中的最后一个元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 被删除的最后一个元素的值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 如果链表为空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeLast</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException &#123;</span><br><span class="line">    <span class="comment">// 检查链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到倒数第二个节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">secondLastNode</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (secondLastNode.getNext().getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">        secondLastNode = secondLastNode.getNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最后一个节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">lastNode</span> <span class="operator">=</span> secondLastNode.getNext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将倒数第二个节点的next指向null，实现删除最后一个节点</span></span><br><span class="line">    secondLastNode.setNext(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回被删除节点的值</span></span><br><span class="line">    <span class="keyword">return</span> lastNode.getElem();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取元素">获取元素</h2><h3 id="get">get</h3><p><code>get(int index)</code>方法用于返回链表中指定位置的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回链表中指定位置的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要获取元素的位置，从0开始计数。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定位置的元素的值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IndexOutOfBoundsException 如果指定位置超出链表范围。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> <span class="keyword">throws</span> IndexOutOfBoundsException &#123;</span><br><span class="line">    <span class="comment">// 检查指定位置是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;指定位置超出链表范围&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到指定位置的节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head.getNext();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        current = current.getNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回指定位置的元素值</span></span><br><span class="line">    <span class="keyword">return</span> current.getElem();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getFirst">getFirst</h3><p><code>getFirst()</code>方法用于获取链表中的第一个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取链表中的第一个元素（头部元素）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 头部元素的值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 如果链表为空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirst</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException &#123;</span><br><span class="line">    <span class="comment">// 检查链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取头节点的下一个节点，即第一个元素</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">firstNode</span> <span class="operator">=</span> head.getNext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回第一个元素的值</span></span><br><span class="line">    <span class="keyword">return</span> firstNode.getElem();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getLast">getLast</h3><p><code>getLast()</code>方法，用于获取尾部元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取链表中的最后一个元素（尾部元素）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 尾部元素的值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchElementException 如果链表为空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLast</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchElementException &#123;</span><br><span class="line">    <span class="comment">// 检查链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最后一个节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">lastNode</span> <span class="operator">=</span> head.getNext();</span><br><span class="line">    <span class="keyword">while</span> (lastNode.getNext() != <span class="literal">null</span>) &#123;</span><br><span class="line">        lastNode = lastNode.getNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最后一个元素的值</span></span><br><span class="line">    <span class="keyword">return</span> lastNode.getElem();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="indexOf">indexOf</h3><p><code>indexOf(int element)</code>方法用于查找链表中指定元素从前往后第一次出现的索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找链表中指定元素从前往后第一次出现的索引。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要查找的元素。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素从前往后第一次出现的索引，如果元素不存在则返回 -1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(<span class="type">int</span> element)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化索引为-1，表示元素不存在</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从链表的第一个节点开始遍历</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head.getNext();</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表，查找指定元素从前往后第一次出现的索引</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.getElem() == element) &#123;</span><br><span class="line">            <span class="comment">// 如果找到指定元素，更新索引值并跳出循环</span></span><br><span class="line">            index = currentIndex;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移动到下一个节点</span></span><br><span class="line">        current = current.getNext();</span><br><span class="line">        currentIndex++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lastIndexOf">lastIndexOf</h3><p><code>lastIndexOf(int element)</code>方法用于查找链表中指定元素最后一次出现的索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找链表中指定元素最后一次出现的索引。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> element 要查找的元素。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 指定元素最后一次出现的索引，如果元素不存在则返回 -1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(<span class="type">int</span> element)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化索引为-1，表示元素不存在</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从链表的第一个节点开始遍历</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> head.getNext();</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表，查找指定元素最后一次出现的索引</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.getElem() == element) &#123;</span><br><span class="line">            <span class="comment">// 更新索引值为最后一次找到元素的索引</span></span><br><span class="line">            lastIndex = currentIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移动到下一个节点</span></span><br><span class="line">        current = current.getNext();</span><br><span class="line">        currentIndex++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lastIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>数组 VS 链表</h1><table><thead><tr><th>特性</th><th>数组</th><th>链表</th></tr></thead><tbody><tr><td>存储方式</td><td>连续的内存块</td><td>分散的节点</td></tr><tr><td>访问元素</td><td>O(1)</td><td>O(n)</td></tr><tr><td>插入元素</td><td>O(n)</td><td>O(1)</td></tr><tr><td>删除元素</td><td>O(n)</td><td>O(1)</td></tr><tr><td>大小变化</td><td>固定，长度不可变</td><td>动态，可灵活扩展</td></tr><tr><td>内存使用</td><td>较少，预先分配空间</td><td>较多，动态分配空间</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】数组</title>
      <link href="/2024/01/21/dsa-02-Array/"/>
      <url>/2024/01/21/dsa-02-Array/</url>
      
        <content type="html"><![CDATA[<h1>数组</h1><p>数组（Array），由相同数据类型的元素（element）的集合组成的数据结构，分配一块连续的内存来存储。</p><h2 id="初始化">初始化</h2><p>初始化一个数组（不给定初始值）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个名为arr的整数数组</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述语句分为两部分：</span></span><br><span class="line"><span class="comment">// 1. int[]：声明一个整数数组</span></span><br><span class="line"><span class="comment">// 2. new int[5]：使用new关键字创建一个包含5个整数元素的新数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：数组索引从0开始，因此这个数组的有效索引范围是0到4（总共5个元素）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，arr是一个长度为5的整数数组，所有元素的初始值为0（基本数据类型的默认值）</span></span><br></pre></td></tr></table></figure><p>初始化一个数组（给定初始值）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个名为nums的整数数组，并初始化数组元素</span></span><br><span class="line"><span class="type">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述语句分为两部分：</span></span><br><span class="line"><span class="comment">// 1. int[]：声明一个整数数组</span></span><br><span class="line"><span class="comment">// 2. &#123; 1, 3, 2, 5, 4 &#125;：初始化数组元素，数组长度为5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：这种初始化方式在声明数组的同时为其赋初值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组元素的含义：</span></span><br><span class="line"><span class="comment">// nums[0] = 1：数组的第一个元素（索引为0）的值为1</span></span><br><span class="line"><span class="comment">// nums[1] = 3：数组的第二个元素（索引为1）的值为3</span></span><br><span class="line"><span class="comment">// nums[2] = 2：数组的第三个元素（索引为2）的值为2</span></span><br><span class="line"><span class="comment">// nums[3] = 5：数组的第四个元素（索引为3）的值为5</span></span><br><span class="line"><span class="comment">// nums[4] = 4：数组的第五个元素（索引为4）的值为4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：数组索引从0开始，因此这个数组的有效索引范围是0到4（总共5个元素）</span></span><br></pre></td></tr></table></figure><h2 id="访问元素">访问元素</h2><p>在数组中访问元素非常高效，我们可以在 <code>𝑂(1)</code> 时间内随机访问数组中的任意一个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个方法randomAccess，该方法接收一个整数数组nums作为参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">randomAccess</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成一个随机索引，范围在数组长度内</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">0</span>, nums.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数组中随机索引对应的元素值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> nums[randomIndex];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回随机获取的数组元素值</span></span><br><span class="line">    <span class="keyword">return</span> randomNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法说明：</span></span><br><span class="line"><span class="comment">// 1. randomIndex = ThreadLocalRandom.current().nextInt(0, nums.length)：</span></span><br><span class="line"><span class="comment">//    通过ThreadLocalRandom生成一个位于 [0, nums.length) 范围内的随机整数，用作数组的索引。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. int randomNum = nums[randomIndex]：</span></span><br><span class="line"><span class="comment">//    通过随机生成的索引获取数组中对应索引位置的元素值，即随机访问数组中的一个元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. return randomNum：</span></span><br><span class="line"><span class="comment">//    将随机获取的数组元素值作为方法的返回值。</span></span><br></pre></td></tr></table></figure><h2 id="插入元素">插入元素</h2><p>数组是一种存储固定大小元素的数据结构。数组的元素在内存中是连续存储的，也就是说，它们是&quot;紧挨着的&quot;。当你想在数组中间插入一个元素时，必须将该元素之后的所有元素都向后移动一位，再将待插入的元素插入到中间位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在数组 nums 的索引 index 处插入元素 num</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> num, <span class="type">int</span> index)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用循环从数组末尾开始，将元素逐个向后移动，为新元素腾出插入位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">        nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在指定索引位置插入新元素</span></span><br><span class="line">    nums[index] = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法说明：</span></span><br><span class="line"><span class="comment">// 1. for (int i = nums.length - 1; i &gt; index; i--)：</span></span><br><span class="line"><span class="comment">//    从数组末尾开始循环，将索引大于给定index的元素逐个向后移动，为新元素腾出插入位置。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. nums[i] = nums[i - 1]：</span></span><br><span class="line"><span class="comment">//    将当前索引位置的元素的值设置为前一个索引位置的元素的值，实现向后移动。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. nums[index] = num：</span></span><br><span class="line"><span class="comment">//    在指定索引位置插入新元素，将新元素的值赋给数组对应索引位置。</span></span><br></pre></td></tr></table></figure><h2 id="删除元素">删除元素</h2><p>与插入元素类似，如果你想删除数组中某一位置的元素，需要将后面的元素都向前移动一位。</p><blockquote><p>删除元素后，原先末尾的元素就已经“无意义”了，因此不用特意修改。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除数组 nums 中索引为 index 处的元素</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用循环从指定索引位置开始，将元素逐个向前移动，实现删除指定位置的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        nums[i] = nums[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法说明：</span></span><br><span class="line"><span class="comment">// 1. for (int i = index; i &lt; nums.length - 1; i++)：</span></span><br><span class="line"><span class="comment">//    从指定索引位置开始循环，将索引大于等于给定index的元素逐个向前移动，实现删除指定位置的元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. nums[i] = nums[i + 1]：</span></span><br><span class="line"><span class="comment">//    将当前索引位置的元素的值设置为后一个索引位置的元素的值，实现向前移动。</span></span><br></pre></td></tr></table></figure><h2 id="遍历数组">遍历数组</h2><p>在Java中，遍历数组即可以通过索引来遍历，也可以通过<code>for-each</code>方式来遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个计数器变量count，用于累加数组元素的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用传统的for循环遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 将当前索引位置的元素值累加到计数器</span></span><br><span class="line">        count += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用增强型for循环（for-each）遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">// 将当前元素值累加到计数器</span></span><br><span class="line">        count += num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法说明：</span></span><br><span class="line"><span class="comment">// 1. int count = 0;：</span></span><br><span class="line"><span class="comment">//    初始化一个计数器变量count，用于累加数组元素的值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. for (int i = 0; i &lt; nums.length; i++)：</span></span><br><span class="line"><span class="comment">//    使用传统的for循环遍历数组，将每个索引位置的元素值累加到计数器。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. for (int num : nums)：</span></span><br><span class="line"><span class="comment">//    使用增强型for循环（for-each）遍历数组，将每个元素值累加到计数器。</span></span><br></pre></td></tr></table></figure><h2 id="查找元素">查找元素</h2><p>在数组中查找特定的元素，可以通过一层循环，遍历数组元素，在每轮循环中判断当前数组元素是否为待查找的元素。若匹配，则输出对应索引，否则返回-1，代表查无此元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在数组 nums 中查找指定元素 target</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法说明：</span></span><br><span class="line"><span class="comment">// 1. for (int i = 0; i &lt; nums.length; i++)：</span></span><br><span class="line"><span class="comment">//    使用传统的for循环遍历数组，检查每个索引位置的元素是否等于目标整数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. if (nums[i] == target)：</span></span><br><span class="line"><span class="comment">//    判断当前索引位置的元素是否等于目标整数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. return i;：</span></span><br><span class="line"><span class="comment">//    如果找到目标整数，返回当前索引位置。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. return -1;：</span></span><br><span class="line"><span class="comment">//    如果未找到目标整数，返回-1表示未找到。</span></span><br></pre></td></tr></table></figure><h2 id="数组扩容">数组扩容</h2><p>在Java中，数组的长度是固定不可变的，一旦数组被创建后，其长度就不能更改。如果你需要扩容数组，通常的做法是创建一个新数组，并将原数组中的元素复制到新数组中。</p><p>举个例子，比如这里给定了一个旧数组 <code>oldArray</code>，然后创建了一个新数组 <code>newArray</code>（长度是旧数组长度的两倍），最后，将旧数组的元素复制到新数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义旧数组 oldArray，包含元素 1, 2, 3, 4, 5</span></span><br><span class="line"><span class="type">int</span>[] oldArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新数组 newArray，长度是旧数组的两倍</span></span><br><span class="line"><span class="type">int</span>[] newArray = <span class="keyword">new</span> <span class="title class_">int</span>[oldArray.length * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用循环将旧数组的元素复制到新数组中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; oldArray.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 将旧数组中的元素逐个复制到新数组的相同索引位置</span></span><br><span class="line">    newArray[i] = oldArray[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前，你也可以通过<code>System.arraycopy</code> 方法将一个数组的内容复制到另一个数组（适用于大规模数据的复制）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] oldArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] newArray = <span class="keyword">new</span> <span class="title class_">int</span>[oldArray.length * <span class="number">2</span>];</span><br><span class="line">System.arraycopy(oldArray, <span class="number">0</span>, newArray, <span class="number">0</span>, oldArray.length);</span><br><span class="line"><span class="comment">// oldArray：源数组，要从这个数组复制元素</span></span><br><span class="line"><span class="comment">// 0：源数组起始位置，从源数组的第0个元素开始复制</span></span><br><span class="line"><span class="comment">// newArray：目标数组，要将元素复制到这个数组</span></span><br><span class="line"><span class="comment">// 0：目标数组起始位置，从目标数组的第0个位置开始粘贴</span></span><br><span class="line"><span class="comment">// oldArray.length：要复制的元素个数，即源数组的长度</span></span><br></pre></td></tr></table></figure><p>或者，也可以<strong>使用 <code>Arrays.copyOf</code> 方法</strong>来复制数组元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] oldArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">newLength</span> <span class="operator">=</span> oldArray.length * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Arrays.copyOf(原数组, 新数组的长度);</span></span><br><span class="line"><span class="type">int</span>[] newArray = Arrays.copyOf(oldArray, newLength);</span><br></pre></td></tr></table></figure><h2 id="数组的优点和局限性">数组的优点和局限性</h2><p>数组是一种在编程中常用的数据结构，具有一些优点和一些局限性。</p><p><strong>优点：</strong></p><ol><li><strong>快速访问：</strong> 数组中的元素通过索引直接访问，这使得对元素的访问速度非常快，支持随机访问，时间复杂度为 <code>O(1)</code>。</li><li><strong>内存连续：</strong> 数组中的元素在内存中是连续存储的，这有助于缓存性能的提升，空间效率高。</li><li><strong>简单易用：</strong> 数组的使用非常简单，适合存储和访问一组相同类型的元素。</li></ol><p><strong>局限性：</strong></p><ol><li><strong>固定大小：</strong> 数组在创建时需要指定固定的大小，这导致了无法动态调整数组的长度。如果需要动态大小的数据结构，可能需要使用其他集合类。</li><li><strong>插入和删除开销大：</strong> 在数组中插入或删除元素通常需要移动其他元素，这导致了较大的时间复杂度（<code>O(n)</code>）。</li><li><strong>浪费空间：</strong> 如果数组的大小超过实际需要的大小，会导致内存浪费。反之，如果数组太小，可能需要频繁地进行扩容操作。</li><li><strong>不适合频繁的查找和删除：</strong> 数组适用于快速访问，但对于频繁的查找和删除操作，可能不是最佳选择。</li></ol><h2 id="动态数组">动态数组</h2><p>在Java中，<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">ArrayList</a> 是一种动态数组，属于 <code>java.util</code> 包。</p><p><code>ArrayList</code>与内置数组的区别在于，数组的大小无法修改（如果要向数组添加或删除元素，必须创建一个新数组）。而<code>ArrayList</code>可以随时添加和删除元素。当 <code>ArrayList</code> 的元素数量超过其当前容量时，<code>ArrayList</code> 会自动增加其容量。</p><blockquote><p>也就是ArrayList帮你实现好了扩容，底层通过创建一个新的数组，将原数组的元素复制到新数组中来实现的。默认情况下，扩容时会将容量翻1.5倍。</p></blockquote><p><code>ArrayList</code> 是使用泛型实现的，可以存储任意类型的对象。在创建 <code>ArrayList</code> 时，可以指定元素的类型。</p><p>下面是 <code>ArrayList</code> 的常见用法：</p><ol><li>创建ArrayList对象：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; cars = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><ol start="2"><li>添加元素：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cars.add(<span class="string">&quot;Volvo&quot;</span>);</span><br><span class="line">cars.add(<span class="string">&quot;BMW&quot;</span>);</span><br><span class="line">cars.add(<span class="string">&quot;Ford&quot;</span>);</span><br><span class="line">cars.add(<span class="string">&quot;Mazda&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>访问元素：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">car</span> <span class="operator">=</span> cars.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li>修改元素：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.set(<span class="number">0</span>, <span class="string">&quot;Opel&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="5"><li>删除元素：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.remove(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="6"><li>清空<code>ArrayList</code>：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.clear();</span><br></pre></td></tr></table></figure><ol start="7"><li>获取<code>ArrayList</code>大小：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> cars.size();</span><br></pre></td></tr></table></figure><ol start="8"><li>遍历<code>ArrayList</code>：</li></ol><p>使用for循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cars.size(); i++) &#123;</span><br><span class="line">  System.out.println(cars.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或使用<code>for-each</code>循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String car : cars) &#123;</span><br><span class="line">  System.out.println(car);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li>排序<code>ArrayList</code>：</li></ol><p>使用<code>Collections.sort()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(cars);  <span class="comment">// 对字符串进行排序</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【设计模式】类间关系</title>
      <link href="/2024/01/19/dp-01-class-relationships/"/>
      <url>/2024/01/19/dp-01-class-relationships/</url>
      
        <content type="html"><![CDATA[<h1>类图</h1><img src="/2024/01/19/dp-01-class-relationships/UML.png" class="" title="UML"><p>类图是一种软件工程中的**统一建模语言（UML）**的静态结构图，用于描述系统的类集合、类的属性和类之间的关系。它主要用于概念建模，将系统的模型转化为代码。</p><p>类图的主要元素包括：</p><ol><li><strong>类的三个区域：</strong><ul><li>最上面是<strong>类的名称</strong>。</li><li>中间部分包含类的属性（字段）。</li><li>底部部分包含类的操作（方法）。</li></ul></li><li><strong>成员可见性：</strong><ul><li><code>+</code> 表示公共（public）成员。</li><li><code>-</code> 表示私有（private）成员。</li><li><code>#</code> 表示保护（protected）成员。</li><li><code>~</code> 表示包（package）成员，即对包内其他成员可见。</li></ul></li><li><strong>类图可进一步结合状态图或UML状态机来描述系统的行为。</strong></li></ol><p>类图是一种强大的工具，通过图形化的方式展示了系统中的类、它们之间的关系以及类的内部结构，帮助我们更好地理解和设计软件系统。</p><h1>类间关系</h1><p>类之间的关系指的是在面向对象编程中，不同类之间可能存在的连接和依赖关系。这些关系描述了类之间的交互方式和相互影响。</p><img src="/2024/01/19/dp-01-class-relationships/Uml_classes.png" class="" title="Uml_classes"><p>类之间的关系主要分为以下六种：</p><ol><li><p><strong>依赖关系（Dependency）</strong>：一个类的实现依赖于另一个类的定义，但两者并没有强耦合。一个类的变化不会影响另一个类的实现，只是依赖关系较弱的一种关系。</p></li><li><p><strong>关联关系（Association）</strong>：两个类之间有一定的关联，表示一个类知道另一个类的存在。关联关系可以是单向的或双向的。关联关系比依赖关系更强，两者之间有更紧密的联系。</p></li><li><p><strong>聚合关系（Aggregation）</strong>：表示整体与部分之间的关系，是一种强于关联关系的关系。聚合关系中，整体和部分可以分开存在。例如，一个班级包含多个学生，但学生可以存在于其他班级。</p></li><li><p><strong>组合关系（Composition）</strong>：也表示整体与部分之间的关系，但是组合关系中整体和部分之间具有更强的耦合。整体和部分的生命周期是相互依赖的，部分不能脱离整体而存在。例如，一个汽车包含引擎和轮胎，它们之间是组合关系。</p></li><li><p><strong>泛化关系（Generalization）</strong>：即继承的反方向，指的是一个类（称为父类、父接口）具有另外的一个（或一些）类（称为子类、子接口）的共有功能。子类可视为其父类的特例，并可以增加新功能。</p></li><li><p><strong>实现关系（Realization）</strong>：表示类与接口之间的关系，一个类实现了一个接口，必须实现接口中定义的所有方法。</p></li></ol><h1>依赖</h1><p>依赖关系是一种比较松散的关系，表示一个类依赖于另一个类的定义，但两者之间的耦合度相对较低。在依赖关系中，一个类的变化不会直接影响到另一个类的实现。</p><p>你可以这么理解，<strong>一个类只要用（using）到了另一个类，那么它们之间就存在依赖关系</strong>。依赖关系仅仅描述了类与类之间的一种使用与被使用的关系。</p><p>比如现在有一个<code>Driver</code>类和一个<code>Car</code>类，<code>Driver</code>类依赖于<code>Car</code>类来实现其功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123; <span class="comment">// 汽车类</span></span><br><span class="line"><span class="keyword">private</span> String brand;  <span class="comment">//品牌</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(String brand)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.brand = brand;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(brand+<span class="string">&quot;汽车在行驶...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Driver</span> &#123;  <span class="comment">//驾驶员类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">(Car car)</span> &#123;  <span class="comment">//方法参数类型为Car；Driver依赖 Car</span></span><br><span class="line">car.move();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DriverAndCar</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Driver</span>().drive(<span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;奥迪&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>Car</code>（汽车）和<code>Driver</code>（驾驶员）之间存在依赖关系。</p><p><code>Driver</code>类有一个<code>drive</code>方法，该方法的参数类型是<code>Car</code>，表明驾驶员依赖于汽车对象。在主类<code>DriverAndCar</code>的<code>main</code>方法中，创建了一个<code>Driver</code>对象并调用其<code>drive</code>方法，传入一个<code>Car</code>对象（奥迪），从而实现了驾驶员驾驶汽车的过程。</p><p><strong>在<code>UML</code>类图中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方</strong>。</p><img src="/2024/01/19/dp-01-class-relationships/Car-Driver.png" class="" title="Car-Driver"><blockquote><p>依赖关系的存在使得类与类之间的耦合度相对较低，有利于代码的灵活性和可维护性。</p></blockquote><h1>关联</h1><p>关联关系，表示一类对象与另一类对象之间有联系的一种结构化关系。它反映了整体与部分之间的关系，通常表现为一个类（或接口）类型的对象作为另一个类的属性（字段）。</p><p>关联关系可以分为单向关联和双向关联。</p><ul><li><p><strong>单向关联：</strong> 一个类的对象作为另一个类的属性，表示一种单向的拥有关系。例如，Customer与Address的关系，表示顾客拥有快递地址。</p></li><li><p><strong>双向关联：</strong> 两个类的对象互为属性，表示双向的关系。例如，Employee与Department的关系，表示员工与部门之间存在双向关联。</p></li></ul><p>关联关系可细分为聚合和组合两种使用方式：</p><ul><li><p><strong>聚合（Aggregation）：</strong> 部分类对象可以独立存在于整体类对象之外，关系较为松散。例如，Company与Employee的关系，表示公司包含员工，但员工可以独立存在。</p></li><li><p><strong>组合（Composition）：</strong> 部分类对象与整体类对象具有统一的生存期，整体类对象的生命周期控制部分类对象。例如，Head与Mouth的关系，表示头部包含口，口的生命周期与头的生命周期相关联。</p></li></ul><p>此外，关联关系中还可能存在<strong>自关联</strong>，即一个类的属性对象类型为该类本身，例如单链表中的结点类。</p><p>在UML类图中，<strong>关联关系用实线连接有关联的两个类</strong>。单向关联用一个带箭头的实线表示，箭头从使用类指向被关联的类，双向关联用带箭头或者没有箭头的实线来表示。</p><img src="/2024/01/19/dp-01-class-relationships/Teacher-Student.png" class="" title="Teacher-Student"><h1>聚合</h1><p>聚合（Aggregation）是一种表示整体与部分的一类特殊的关联关系，可以理解为一种“… owns a …”（拥有）关系。</p><p>聚合关系是一种弱关联，部分对象可以独立存在，不依赖于整体对象。它们可以具有各自的生命周期。比如图书馆包含(owns a) 学生和书籍（即使没有图书馆，学生也可以存在）。再比如老师和课程之间的关系也是聚合。一个教授可以教授多门课程，而每门课程又可以由不同的教授来教，并且各自的生命周期可以独立存在。</p><p>在代码实现时，类对象通过构造器或<code>setter</code>方法进行注入。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123; <span class="comment">// 部分类</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span> &#123;   <span class="comment">//整体类</span></span><br><span class="line"><span class="keyword">private</span> String companyName;</span><br><span class="line"><span class="keyword">private</span> List&lt;Employee&gt; employees;  <span class="comment">//Company聚合Employee</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Company</span><span class="params">(String companyName)</span> &#123;  <span class="comment">//构造方法</span></span><br><span class="line"><span class="built_in">this</span>.companyName = companyName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getCompanyName</span><span class="params">()</span> &#123;  <span class="comment">//getter</span></span><br><span class="line"><span class="keyword">return</span> companyName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmployees</span><span class="params">(List&lt;Employee&gt; employees)</span> &#123;  <span class="comment">//setter</span></span><br><span class="line"><span class="built_in">this</span>.employees = employees;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getEmployees</span><span class="params">()</span> &#123;  <span class="comment">//getter</span></span><br><span class="line"><span class="keyword">return</span> employees;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><p><strong>Company类（整体类）：</strong> 代表了整体，即公司。它有一个属性是<code>employees</code>，用于存储雇佣的员工列表。</p></li><li><p><strong>Employee类（部分类）：</strong> 代表了部分，即员工。员工有一个属性<code>name</code>表示姓名。</p></li></ul><p>通过这个设计，公司（整体类）可以包含多个员工（部分类），而员工可以独立存在，不依赖于任何特定的公司（公司关了，员工也不会消失）。这符合聚合关系的特性，即<strong>部分类对象可以脱离整体类对象而独立存在</strong>。</p><p>类图如下：</p><img src="/2024/01/19/dp-01-class-relationships/aggregation.png" class="" title="aggregation"><p>聚合关系表示为<strong>一条实线，在关联端带有一个未填充的菱形</strong>，该实线连接到表示聚合的类。</p><h1>组合</h1><p>组合（Composition）关系是一类“强”的整体与部分的包含关系（&quot; … is a part of …&quot;），部分类对象与整体类对象具有统一的生存期。当整体类对象消亡时，部分类对象也将消亡。或者说，整体类对象控制了部分类对象的生命周期。</p><p>整体对象完全负责创建、销毁和管理部分类对象。部分类对象无法独立存在或被其他对象所拥有。在代码实现时，<strong>部分类对象在整体类属性声明时或它的构造方法里实例化</strong>。</p><p>举例：</p><p>公司与公司部门之间的关系可以被视为组合关系。一个公司包含多个部门，而且公司的存在决定了部门的存在，整体对象（公司）管理部分对象（部门），整体对象的销毁将导致部分对象的销毁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String companyName;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Department&gt; departments;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Company</span><span class="params">(String companyName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.companyName = companyName;</span><br><span class="line">        <span class="built_in">this</span>.departments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCompanyName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> companyName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDepartment</span><span class="params">(Department department)</span> &#123;</span><br><span class="line">        departments.add(department);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Department&gt; <span class="title function_">getDepartments</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> departments;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他公司相关的方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeCompany</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 公司关闭时，销毁所有部门</span></span><br><span class="line">        <span class="keyword">for</span> (Department department : departments) &#123;</span><br><span class="line">            department.closeDepartment();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Company &quot;</span> + companyName + <span class="string">&quot; is closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String departmentName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Department</span><span class="params">(String departmentName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.departmentName = departmentName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDepartmentName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> departmentName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 部门相关的方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeDepartment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 部门关闭时的清理操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Department &quot;</span> + departmentName + <span class="string">&quot; is closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类图如下：</p><img src="/2024/01/19/dp-01-class-relationships/composition.png" class="" title="composition"><p>在类图中，组合关系通常用<strong>实心的菱形箭尾和实线</strong>表示，箭头指向整体对象。</p><h1>泛化</h1><p>泛化（Generalization）关系指的是<strong>一个类（称为父类、父接口）具有另外的一个（或一些）类（称为子类、子接口）的共有功能</strong>。实际上就是类（或接口）之间的继承关系。</p><p>子类继承了父类的属性和方法，可以视为是父类的特例，同时具有扩展或增加新功能的能力。通过泛化，可以将通用的行为和属性提取到父类中，从而提高代码的复用性和可维护性。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is barking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">meow</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat is meowing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Dog</code>和<code>Cat</code>类继承自<code>Animal</code>类，形成了泛化关系。<code>Animal</code>类包含了共有的<code>eat</code>方法，而<code>Dog</code>和<code>Cat</code>类分别增加了独有的功能。</p><img src="/2024/01/19/dp-01-class-relationships/Generalization.png" class="" title="Generalization"><p>在类图中，泛化关系通常用带空心三角形的箭头和实线表示。箭头指向父类，表示子类继承自父类。</p><h1>实现</h1><p>实现（Realization）关系很简单，就是指一个<code>class</code>类实现<code>interface</code>接口（可以是多个）。实现类需要实现接口中声明的所有抽象方法。</p><p>在Java中此类关系通过关键字<code>implements</code>明确标识。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;<span class="comment">//定义接口</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ship</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span> &#123;<span class="comment">//实现接口</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;船在水上行驶&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span> &#123;<span class="comment">//实现接口</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;汽车在公路上行驶&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2024/01/19/dp-01-class-relationships/Realization.png" class="" title="Realization"><p>在类图中，实现关系用<strong>带空心三角形箭头的虚线</strong>表示。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类之间的关系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语言基础</title>
      <link href="/2024/01/19/java-01-basis/"/>
      <url>/2024/01/19/java-01-basis/</url>
      
        <content type="html"><![CDATA[<h1>标识符</h1><p>标识符是用来命名变量、方法、类等的名称。其中：</p><ol><li><strong>首字符</strong>必须以字母（<code>A-Z</code> 或 <code>a-z</code>）、下划线<code>_</code>或美元符号<code>$</code>开头。</li><li><strong>后续字符</strong>可以是字母、下划线<code>_</code>、美元符号<code>$</code>或数字。</li></ol><p>Java是区分大小写的，即<code>identifier</code>和<code>Identifier</code>被视为不同的标识符。</p><p>不能使用Java的关键字作为标识符。例如，<code>this</code>是关键字，不能用作标识符。</p><p>Java关键字如下：</p><img src="/2024/01/19/java-01-basis/guanjianzi.png" class="" title="guanjianzi"><h1>基本数据类型</h1><p>基本数据类型是 <code>Java</code> 语言操作数据的基础，包括 <code>boolean</code>、<code>char</code>、<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code> 和 <code>double</code>，共 8 种。</p><p>注意，变量可以分为局部变量、成员变量和静态变量。</p><p>当变量是局部变量时（比如在方法中定义的变量）必须先初始化再使用。否则会报错：<code>The local variable xxx may not have been initialized</code>。</p><p>当变量时成员变量或者静态变量时，可以不进行初始化，此时会有默认值，如下所示：</p><table><thead><tr><th style="text-align:center">基本数据类型</th><th style="text-align:center">默认值</th><th style="text-align:center">大小</th></tr></thead><tbody><tr><td style="text-align:center"><code>boolean</code></td><td style="text-align:center"><code>false</code></td><td style="text-align:center">1 比特</td></tr><tr><td style="text-align:center"><code>char</code></td><td style="text-align:center"><code>'\u0000'</code></td><td style="text-align:center">2 字节</td></tr><tr><td style="text-align:center"><code>byte</code></td><td style="text-align:center"><code>0</code></td><td style="text-align:center">1 字节</td></tr><tr><td style="text-align:center"><code>short</code></td><td style="text-align:center"><code>0</code></td><td style="text-align:center">2 字节</td></tr><tr><td style="text-align:center"><code>int</code></td><td style="text-align:center"><code>0</code></td><td style="text-align:center">4 字节</td></tr><tr><td style="text-align:center"><code>long</code></td><td style="text-align:center"><code>0L</code></td><td style="text-align:center">8 字节</td></tr><tr><td style="text-align:center"><code>float</code></td><td style="text-align:center"><code>0.0f</code></td><td style="text-align:center">4 字节</td></tr><tr><td style="text-align:center"><code>double</code></td><td style="text-align:center"><code>0.0</code></td><td style="text-align:center">8 字节</td></tr></tbody></table><h1>引用数据类型</h1><p>引用数据类型在Java中是一种特殊的数据类型，它们存储的是对象的引用地址，而不是对象本身。</p><ol><li><strong>引用数据类型：</strong> 除了基本数据类型以外的所有类型都属于引用数据类型。这包括数组、类（对象）以及接口。</li><li><strong>内存存储：</strong> 引用数据类型的变量在内存中存储的是一个引用地址，这个地址指向实际对象的内存地址。</li><li><strong>操作对象：</strong> 通过引用，我们可以操作对象，调用对象的方法、访问对象的属性等。</li></ol><h1>包装器类型</h1><p>包装器类型（Wrapper Types）是Java中一组用于将基本数据类型转换为对象的类。在Java中，基本数据类型（如<code>int</code>、<code>char</code>、<code>boolean</code>等）是不具备对象特性的，但有时候需要在对象上执行操作，这时就需要使用包装器类型。</p><p>每个基本数据类型都有对应的包装器类，它们属于<code>java.lang</code>包。以下是基本数据类型及其对应的包装器类型：</p><ul><li><code>Byte</code>（对应 <code>byte</code>）</li><li><code>Short</code>（对应 <code>short</code>）</li><li><code>Integer</code>（对应 <code>int</code>）</li><li><code>Long</code>（对应 <code>long</code>）</li><li><code>Float</code>（对应 <code>float</code>）</li><li><code>Double</code>（对应 <code>double</code>）</li><li><code>Character</code>（对应 <code>char</code>）</li><li><code>Boolean</code>（对应 <code>boolean</code>）</li></ul><p>这些包装器类型提供了一些额外的功能，例如转换为字符串、解析字符串、比较对象等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）转换为字符串</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">intValue</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">stringValue</span> <span class="operator">=</span> intValue.toString(); <span class="comment">// 将Integer对象转换为字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;String value: &quot;</span> + stringValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）解析字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">numberStr</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">parsedValue</span> <span class="operator">=</span> Integer.valueOf(numberStr); <span class="comment">// 将字符串解析为Integer对象</span></span><br><span class="line">System.out.println(<span class="string">&quot;Parsed value: &quot;</span> + parsedValue);</span><br></pre></td></tr></table></figure><p>另外，包装器也用于在集合类（如集合框架中的List、Map等）中存储基本数据类型的值，因为集合类只能存储对象。</p><p>使用包装器类型可以方便地进行对象操作，但在实际编程中，也可以通过自动装箱（Autoboxing）和自动拆箱（Unboxing）来方便地在基本数据类型和包装器类型之间进行转换。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">42</span>; <span class="comment">// 将int类型自动装箱为Integer对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动拆箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> num; <span class="comment">// 将Integer对象自动拆箱为int类型</span></span><br></pre></td></tr></table></figure><p>总体而言，包装器类型在Java中用于处理基本数据类型与对象之间的转换和操作，提供了更多的灵活性。</p><h1>运算符</h1><p>Java的运算符可分为多个类别，包括算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符，以及三元运算符。</p><ol><li><p><strong>算术运算符：</strong></p><ul><li><code>+</code>：加法</li><li><code>-</code>：减法</li><li><code>*</code>：乘法</li><li><code>/</code>：除法</li><li><code>%</code>：取模（求余）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 加法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + b; <span class="comment">// 13</span></span><br><span class="line"><span class="comment">// 减法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">difference</span> <span class="operator">=</span> a - b; <span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 乘法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> a * b; <span class="comment">// 30</span></span><br><span class="line"><span class="comment">// 除法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">quotient</span> <span class="operator">=</span> a / b; <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 取模</span></span><br><span class="line"><span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> a % b; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>关系运算符：</strong></p><ul><li><code>==</code>：等于</li><li><code>!=</code>：不等于</li><li><code>&gt;</code>：大于</li><li><code>&lt;</code>：小于</li><li><code>&gt;=</code>：大于等于</li><li><code>&lt;=</code>：小于等于</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 等于</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual</span> <span class="operator">=</span> x == y; <span class="comment">// 结果为 false</span></span><br><span class="line"><span class="comment">// 不等于</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isNotEqual</span> <span class="operator">=</span> x != y; <span class="comment">// 结果为 true</span></span><br><span class="line"><span class="comment">// 大于</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isGreaterThan</span> <span class="operator">=</span> x &gt; y; <span class="comment">// 结果为 false</span></span><br><span class="line"><span class="comment">// 小于</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isLessThan</span> <span class="operator">=</span> x &lt; y; <span class="comment">// 结果为 true</span></span><br></pre></td></tr></table></figure></li><li><p><strong>逻辑运算符：</strong></p><ul><li><code>&amp;&amp;</code>：逻辑与（AND）</li><li><code>||</code>：逻辑或（OR）</li><li><code>!</code>：逻辑非（NOT）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">condition1</span> <span class="operator">=</span> <span class="literal">true</span>, condition2 = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 逻辑与</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">resultAnd</span> <span class="operator">=</span> condition1 &amp;&amp; condition2; <span class="comment">// 结果为 false</span></span><br><span class="line"><span class="comment">// 逻辑或</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">resultOr</span> <span class="operator">=</span> condition1 || condition2; <span class="comment">// 结果为 true</span></span><br><span class="line"><span class="comment">// 逻辑非</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">resultNot</span> <span class="operator">=</span> !condition1; <span class="comment">// 结果为 false</span></span><br></pre></td></tr></table></figure></li><li><p><strong>位运算符：</strong></p><ul><li><code>&amp;</code>：按位与</li><li><code>|</code>：按位或</li><li><code>^</code>：按位异或</li><li><code>~</code>：按位取反</li><li><code>&lt;&lt;</code>：左移</li><li><code>&gt;&gt;</code>：右移</li><li><code>&gt;&gt;&gt;</code>：无符号右移</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">5</span>, num2 = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 按位与</span></span><br><span class="line"><span class="type">int</span> <span class="variable">bitwiseAnd</span> <span class="operator">=</span> num1 &amp; num2; <span class="comment">// 结果为 1</span></span><br><span class="line"><span class="comment">// 按位或</span></span><br><span class="line"><span class="type">int</span> <span class="variable">bitwiseOr</span> <span class="operator">=</span> num1 | num2; <span class="comment">// 结果为 7</span></span><br><span class="line"><span class="comment">// 按位异或</span></span><br><span class="line"><span class="type">int</span> <span class="variable">bitwiseXor</span> <span class="operator">=</span> num1 ^ num2; <span class="comment">// 结果为 6</span></span><br><span class="line"><span class="comment">// 按位取反</span></span><br><span class="line"><span class="type">int</span> <span class="variable">bitwiseNot</span> <span class="operator">=</span> ~num1; <span class="comment">// 结果为 -6</span></span><br></pre></td></tr></table></figure></li><li><p><strong>赋值运算符：</strong></p><ul><li><code>=</code>：赋值</li><li><code>+=</code>：加法赋值</li><li><code>-=</code>：减法赋值</li><li><code>*=</code>：乘法赋值</li><li><code>/=</code>：除法赋值</li><li><code>%=</code>：取模赋值</li><li><code>&amp;=</code>：按位与赋值</li><li><code>|=</code>：按位或赋值</li><li><code>^=</code>：按位异或赋值</li><li><code>&lt;&lt;=</code>：左移赋值</li><li><code>&gt;&gt;=</code>：右移赋值</li><li><code>&gt;&gt;&gt;=</code>：无符号右移赋值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">num3 += <span class="number">5</span>; <span class="comment">// 等同于 num3 = num3 + 5;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>三元运算符：</strong></p><ul><li><code>? :</code>：条件运算符，根据条件的真假选择不同的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 条件运算符</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (a &gt; b) ? a : b; <span class="comment">// 结果为 10</span></span><br></pre></td></tr></table></figure></li></ol><h1>流程控制语句</h1><p>流程控制语句在Java中用于控制程序的执行流程。</p><ol><li><p><strong>简单条件语句（if）:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;x 大于 5&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>复合条件语句（if…else）:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="keyword">if</span> (y % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;y 是偶数&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;y 是奇数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>开关语句（switch）:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">switch</span> (dayOfWeek) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 其他情况</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;其他天&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>布尔表达式（三元运算符）:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (a &gt; b) ? a : b;</span><br><span class="line">System.out.println(<span class="string">&quot;较大的值是：&quot;</span> + result);</span><br></pre></td></tr></table></figure></li><li><p><strong>循环语句：</strong></p><ul><li><p><strong>for循环:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;循环次数：&quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>while循环:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;循环次数：&quot;</span> + (count + <span class="number">1</span>));</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>do…while循环:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;循环次数：&quot;</span> + num);</span><br><span class="line">    num++;</span><br><span class="line">&#125; <span class="keyword">while</span> (num &lt;= <span class="number">4</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>中止循环（break, continue, return）:</strong></p><ul><li><strong>break:</strong> 用于跳出循环。</li><li><strong>continue:</strong> 用于跳过当前循环的剩余代码，继续下一次循环。</li><li><strong>return:</strong> 用于在方法中返回值并中止方法的执行。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 当 i 等于 3 时跳出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;循环次数：&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 当 j 等于 3 时跳过当前循环的剩余代码，继续下一次循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;循环次数：&quot;</span> + j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findNumber</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 找到目标值时返回并中止方法的执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 如果未找到目标值，则返回 -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Math</h1><p><code>java.lang.Math</code> 类提供了一系列用于数学运算的静态方法和常量。</p><ol><li><p><strong>方法：</strong></p><ul><li><p><strong><code>abs(double d)</code>：</strong> 返回参数 d 的绝对值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">absoluteValue</span> <span class="operator">=</span> Math.abs(-<span class="number">5.67</span>); <span class="comment">// 返回 5.67</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>min(double d1, double d2)</code>：</strong> 返回参数 d1 和 d2 中的小者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">minValue</span> <span class="operator">=</span> Math.min(<span class="number">3.14</span>, <span class="number">2.71</span>); <span class="comment">// 返回 2.71</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>max(double d1, double d2)</code>：</strong> 返回参数 d1 和 d2 中的大者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">maxValue</span> <span class="operator">=</span> Math.max(<span class="number">3.14</span>, <span class="number">2.71</span>); <span class="comment">// 返回 3.14</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>sqrt(double d)</code>：</strong> 返回参数 d 的平方根。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">squareRoot</span> <span class="operator">=</span> Math.sqrt(<span class="number">9</span>); <span class="comment">// 返回 3.0</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>pow(double d1, double d2)</code>：</strong> 返回 d1 的 d2 次幂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">powerResult</span> <span class="operator">=</span> Math.pow(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 返回 8.0</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>random()</code>：</strong> 返回 [0, 1) 范围内的随机数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">randomValue</span> <span class="operator">=</span> Math.random(); <span class="comment">// 返回 [0, 1) 范围内的随机数</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>常量：</strong></p><ul><li><p><strong><code>PI</code>：</strong> 圆周率 π，类型为 double。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">piValue</span> <span class="operator">=</span> Math.PI; <span class="comment">// 圆周率，约 3.141592653589793</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>E</code>：</strong> 自然对数的底 e，类型为 double。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">eValue</span> <span class="operator">=</span> Math.E; <span class="comment">// 自然对数的底，约 2.718281828459045</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h1>String</h1><p><code>String</code> 类是 Java 中表示字符串的不可变类，它提供了丰富的方法来处理字符串。由于字符串是不可变的，每次对字符串进行操作都会生成一个新的字符串对象。</p><ol><li><p><strong>创建字符串：</strong></p><ul><li><p>使用字面值创建字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用构造函数创建字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>字符串长度：</strong></p><ul><li>使用 <code>length()</code> 方法获取字符串的长度：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> text.length(); <span class="comment">// 返回 13</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>字符串连接：</strong></p><ul><li>使用 <code>+</code> 运算符或 <code>concat()</code> 方法连接字符串：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> greeting + <span class="string">&quot;, &quot;</span> + name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="type">String</span> <span class="variable">concatenatedMessage</span> <span class="operator">=</span> greeting.concat(<span class="string">&quot;, &quot;</span>).concat(name).concat(<span class="string">&quot;!&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>提取子串：</strong></p><ul><li>使用 <code>substring(int beginIndex)</code> 或 <code>substring(int beginIndex, int endIndex)</code> 提取子串：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">original</span> <span class="operator">=</span> <span class="string">&quot;Java Programming&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">subString1</span> <span class="operator">=</span> original.substring(<span class="number">5</span>);      <span class="comment">// 返回 &quot;Programming&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">subString2</span> <span class="operator">=</span> original.substring(<span class="number">0</span>, <span class="number">4</span>);  <span class="comment">// 返回 &quot;Java&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>查找字符或子串：</strong></p><ul><li>使用 <code>indexOf(char ch)</code> 或 <code>indexOf(String str)</code> 查找字符或子串的索引：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">indexOfComma</span> <span class="operator">=</span> text.indexOf(<span class="string">&#x27;,&#x27;</span>);           <span class="comment">// 返回 5</span></span><br><span class="line"><span class="type">int</span> <span class="variable">indexOfWorld</span> <span class="operator">=</span> text.indexOf(<span class="string">&quot;World&quot;</span>);      <span class="comment">// 返回 7</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>替换字符或子串：</strong></p><ul><li>使用 <code>replace(char oldChar, char newChar)</code> 或 <code>replace(CharSequence target, CharSequence replacement)</code> 替换字符或子串：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">original</span> <span class="operator">=</span> <span class="string">&quot;Hello, Java!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">replaced</span> <span class="operator">=</span> original.replace(<span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;World&#x27;</span>);  <span class="comment">// 返回 &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>转换大小写：</strong></p><ul><li>使用 <code>toLowerCase()</code> 或 <code>toUpperCase()</code> 转换大小写：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Java Programming&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">lowercase</span> <span class="operator">=</span> text.toLowerCase();  <span class="comment">// 返回 &quot;java programming&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">uppercase</span> <span class="operator">=</span> text.toUpperCase();  <span class="comment">// 返回 &quot;JAVA PROGRAMMING&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>去除首尾空白：</strong></p><ul><li>使用 <code>trim()</code> 方法去除字符串首尾的空格：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">paddedText</span> <span class="operator">=</span> <span class="string">&quot;   Trim Me!   &quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">trimmedText</span> <span class="operator">=</span> paddedText.trim();  <span class="comment">// 返回 &quot;Trim Me!&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>判断字符串相等：</strong></p><ul><li>使用 <code>equals()</code> 或 <code>equalsIgnoreCase()</code> 方法判断字符串是否相等：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual</span> <span class="operator">=</span> str1.equals(str2);              <span class="comment">// 返回 false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqualIgnoreCase</span> <span class="operator">=</span> str1.equalsIgnoreCase(str2);  <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p>需要注意的是，由于<strong>字符串是不可变的</strong>，对字符串的任何修改操作返回的都是一个新的字符串对象。</p><h1>字符串与其他类型的转换</h1><p><strong>字符串和数值之间的转换</strong>：</p><ul><li><p>使用 <code>Integer.parseInt(String str)</code> 将字符串转换为整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">strNumber</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> Integer.parseInt(strNumber); <span class="comment">// 结果为 123</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Double.parseDouble(String str)</code> 将字符串转换为双精度浮点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">strDouble</span> <span class="operator">=</span> <span class="string">&quot;3.14&quot;</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">doubleValue</span> <span class="operator">=</span> Double.parseDouble(strDouble); <span class="comment">// 结果为 3.14</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>String.valueOf(类型 value)</code> 将数值转换为字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">strValue</span> <span class="operator">=</span> String.valueOf(intValue); <span class="comment">// 结果为 &quot;42&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>或者直接使用数值类型的 <code>toString()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">doubleValue</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">strDouble</span> <span class="operator">=</span> Double.toString(doubleValue); <span class="comment">// 结果为 &quot;3.14&quot;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>注意！在进行字符串转换为数值时，要确保字符串的格式是合法的数值格式，否则可能会抛出 <code>NumberFormatException</code></strong>。</p></blockquote><p><strong>字符串和字符数组之间的转换</strong>：</p><ul><li><p>使用 <code>toCharArray()</code> 方法将字符串转换为字符数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] charArray = str.toCharArray(); <span class="comment">// 结果为 &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>String(char[] value)</code> 构造函数将字符数组转换为字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] charArray = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray); <span class="comment">// 结果为 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>String.valueOf(char[] data)</code> 方法将字符数组转换为字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] charArray = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(charArray); <span class="comment">// 结果为 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>new String(char[] value, int offset, int count)</code> 构造函数可以指定字符数组的子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] charArray = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray, <span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 结果为 &quot;ell&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h1>StringBuffer</h1><p><code>StringBuffer</code> 是 Java 中表示可变字符串的类，与 <code>String</code> 不同，<code>StringBuffer</code> 的内容可以动态修改。这种可变性使得 <code>StringBuffer</code> 更适合<strong>频繁进行字符串操作</strong>的场景。</p><ol><li><p><strong>创建 StringBuffer 对象：</strong></p><ul><li><p>使用无参构造函数创建空的 <code>StringBuffer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br></pre></td></tr></table></figure></li><li><p>使用带容量参数的构造函数创建指定容量的 <code>StringBuffer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用字符串作为初始值创建 <code>StringBuffer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>获取容量和长度：</strong></p><ul><li><p>使用 <code>capacity()</code> 获取 <code>StringBuffer</code> 对象的总容量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">totalCapacity</span> <span class="operator">=</span> buffer1.capacity();</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>length()</code> 获取 <code>StringBuffer</code> 对象中字符串的长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">currentLength</span> <span class="operator">=</span> buffer1.length();</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>追加字符串：</strong></p><ul><li>使用 <code>append(类型 s)</code> 在字符串末尾追加内容：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">buffer.append(<span class="string">&quot;, World!&quot;</span>); <span class="comment">// 结果为 &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>插入字符串：</strong></p><ul><li>使用 <code>insert(int offset, 类型 s)</code> 在指定位置插入内容：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">buffer.insert(<span class="number">5</span>, <span class="string">&quot;, World!&quot;</span>); <span class="comment">// 结果为 &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>删除字符或子串：</strong></p><ul><li><p>使用 <code>deleteCharAt(int index)</code> 删除指定位置的字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">buffer.deleteCharAt(<span class="number">5</span>); <span class="comment">// 结果为 &quot;HelloWorld!&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>delete(int start, int end)</code> 删除指定范围的字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">buffer.delete(<span class="number">5</span>, <span class="number">13</span>); <span class="comment">// 结果为 &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>替换字符或子串：</strong></p><ul><li>使用 <code>replace(int start, int end, String str)</code> 替换指定范围的字符串：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello, Java!&quot;</span>);</span><br><span class="line">buffer.replace(<span class="number">7</span>, <span class="number">11</span>, <span class="string">&quot;World&quot;</span>); <span class="comment">// 结果为 &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>反转字符串：</strong></p><ul><li>使用 <code>reverse()</code> 方法反转 <code>StringBuffer</code> 中的字符顺序：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">buffer.reverse(); <span class="comment">// 结果为 &quot;olleH&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>获取子串：</strong></p><ul><li>使用 <code>substring(int start)</code> 或 <code>substring(int start, int end)</code> 获取子串：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">subString1</span> <span class="operator">=</span> buffer.substring(<span class="number">7</span>);      <span class="comment">// 返回 &quot;World!&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">subString2</span> <span class="operator">=</span> buffer.substring(<span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// 返回 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>转换为 String：</strong></p><ul><li>使用 <code>toString()</code> 将 <code>StringBuffer</code> 对象转换为 <code>String</code> 对象：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> buffer.toString();</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1>一维数组</h1><p>一维数组是一种基本的数据结构，用于存储相同数据类型的元素集合。在 Java 中，一维数组是对象，可以通过索引访问数组中的元素。</p><ol><li><p><strong>数组的声明和初始化：</strong></p><ul><li><p><strong>声明数组：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明整型数组</span></span><br><span class="line"><span class="type">int</span>[] intArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明字符串数组</span></span><br><span class="line">String[] stringArray;</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化数组：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化整型数组</span></span><br><span class="line">intArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">// 创建长度为 5 的整型数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化字符串数组</span></span><br><span class="line">stringArray = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C++&quot;</span>&#125;;<span class="comment">// 注意，这里不能指定元素个数</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>访问数组元素：</strong></p><ul><li>使用索引访问数组元素，索引从 0 开始：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">firstElement</span> <span class="operator">=</span> numbers[<span class="number">0</span>]; <span class="comment">// 获取数组的第一个元素，值为 1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>数组的长度：</strong></p><ul><li>使用 <code>length</code> 属性获取数组的长度：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">arrayLength</span> <span class="operator">=</span> numbers.length; <span class="comment">// 获取数组的长度，值为 5</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>遍历数组：</strong></p><ul><li><p>使用循环遍历数组中的所有元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    System.out.println(numbers[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用增强型 for 循环（for-each）遍历数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>数组的初始化方式：</strong></p><ul><li><p><strong>动态初始化：</strong> 在声明数组的同时为其分配空间并指定长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] dynamicArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure></li><li><p><strong>静态初始化：</strong> 在声明数组的同时为其指定元素值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] staticArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>多维数组：</strong></p><ul><li>一维数组的元素可以是另一个一维数组，形成多维数组。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] twoDArray = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;;<span class="comment">// 二维数组</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>数组的注意事项：</strong></p><ul><li>数组的索引越界：访问不存在的索引会导致 <code>ArrayIndexOutOfBoundsException</code>。</li><li>数组的长度不可变：<strong>一旦数组被创建，其长度不可改变</strong>。</li></ul></li></ol><h1>Arrays</h1><p><code>Arrays</code> 类是 Java 中用于操作数组的工具类，它提供了一系列静态方法，用于对数组进行排序、搜索、比较等操作。<code>Arrays</code> 类中的方法都是静态方法，直接通过类名调用即可。</p><p>以下是 <code>Arrays</code> 类的一些常用方法：</p><ol><li><p><strong>数组排序：</strong></p><ul><li><p>使用 <code>sort(类型[] array)</code> 方法对数组进行升序排序。对于对象数组，要求元素类型实现 <code>Comparable</code> 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">7</span>&#125;;</span><br><span class="line">Arrays.sort(numbers); <span class="comment">// 结果为 &#123;1, 2, 5, 7, 8&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>sort(类型[] array, Comparator&lt;? super 类型&gt; comparator)</code> 方法进行自定义排序，要求提供一个比较器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(names, Comparator.reverseOrder()); <span class="comment">// 结果为 &#123;&quot;John&quot;, &quot;Charlie&quot;, &quot;Bob&quot;, &quot;Alice&quot;&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>数组搜索：</strong></p><ul><li><p>使用 <code>binarySearch(类型[] array, 类型 key)</code> 方法在<strong>有序数组</strong>中进行二分查找。对于对象数组，要求元素类型实现 <code>Comparable</code> 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(numbers, <span class="number">5</span>); <span class="comment">// 结果为 2</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>binarySearch(类型[] array, int fromIndex, int toIndex, 类型 key)</code> 在指定范围内进行二分查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(numbers, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 结果为 -3</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>数组填充：</strong></p><ul><li><p>使用 <code>fill(类型[] array, 类型 value)</code> 方法将数组的所有元素填充为指定值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">Arrays.fill(numbers, <span class="number">42</span>); <span class="comment">// 结果为 &#123;42, 42, 42, 42, 42&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>fill(类型[] array, int fromIndex, int toIndex, 类型 value)</code> 在指定范围内填充数组元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">Arrays.fill(numbers, <span class="number">1</span>, <span class="number">4</span>, <span class="number">42</span>); <span class="comment">// 结果为 &#123;0, 42, 42, 42, 0&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>数组复制：</strong></p><ul><li><p>使用 <code>copyOf(类型[] original, int newLength)</code> 方法复制数组的一部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] source = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] destination = Arrays.copyOf(source, <span class="number">3</span>); <span class="comment">// 结果为 &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>copyOfRange(类型[] original, int from, int to)</code> 复制数组的指定范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] source = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] destination = Arrays.copyOfRange(source, <span class="number">1</span>, <span class="number">4</span>); <span class="comment">// 结果为 &#123;2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>数组比较：</strong></p><ul><li><p>使用 <code>equals(类型[] a, 类型[] b)</code> 方法比较两个数组是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual</span> <span class="operator">=</span> Arrays.equals(arr1, arr2); <span class="comment">// 结果为 true</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>deepEquals(Object[] a1, Object[] a2)</code> 方法递归比较两个对象数组是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr1 = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span>[][] arr2 = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual</span> <span class="operator">=</span> Arrays.deepEquals(arr1, arr2); <span class="comment">// 结果为 true</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h1>二维数组</h1><p>二维数组是一种特殊的数组，它可以看作是数组的数组。在 Java 中，二维数组是一个由行和列组成的表格状数据结构。</p><p>以下是关于二维数组的一些基本概念和操作：</p><ol><li><p><strong>定义和初始化：</strong></p><ul><li><p>定义二维数组的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据类型[][] 数组名 = new 数据类型[行数][列数];</span></span><br><span class="line"><span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>]; <span class="comment">// 3行4列的二维数组</span></span><br></pre></td></tr></table></figure></li><li><p>初始化二维数组时，可以同时指定元素的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>访问元素：</strong></p><ul><li>通过指定行和列的索引访问二维数组的元素：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> matrix[<span class="number">1</span>][<span class="number">2</span>]; <span class="comment">// 访问第2行第3列的元素，结果为 6</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>遍历二维数组：</strong></p><ul><li>使用嵌套循环遍历二维数组的所有元素：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">        System.out.print(matrix[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(); <span class="comment">// 换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>获取行数和列数：</strong></p><ul><li>使用 <code>length</code> 属性获取二维数组的行数和列数：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrix.length;    <span class="comment">// 获取行数，结果为 3</span></span><br><span class="line"><span class="type">int</span> <span class="variable">columns</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length; <span class="comment">// 获取列数，结果为 3</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>不规则二维数组：</strong></p><ul><li>二维数组的各行可以有不同的长度，创建不规则二维数组时，只需指定每行的长度即可：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] irregularMatrix = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用 Arrays 类操作二维数组：</strong></p><ul><li><p>使用 <code>Arrays.deepToString(Object[] array)</code> 方法可以方便地将二维数组转换为字符串，便于输出和调试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.deepToString(matrix));</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Arrays.copyOf</code> 或 <code>Arrays.copyOfRange</code> 可以复制部分或全部二维数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] copyMatrix = Arrays.copyOf(matrix, matrix.length);</span><br><span class="line"><span class="type">int</span>[][] subMatrix = Arrays.copyOfRange(matrix, <span class="number">0</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Arrays.fill(类型[] array, 类型 value)</code> 可以为二维数组的所有元素赋相同的值。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两整数之和</title>
      <link href="/2024/01/19/leetcode-371/"/>
      <url>/2024/01/19/leetcode-371/</url>
      
        <content type="html"><![CDATA[<h1>题目</h1><p><a href="https://leetcode.cn/problems/sum-of-two-integers/description/">371. 两整数之和 - 力扣（LeetCode）</a></p><p>给你两个整数 <code>a</code> 和 <code>b</code> ，<strong>不使用</strong> 运算符 <code>+</code> 和 <code>-</code> ，计算并返回两整数之和。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 1, b = 2</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 2, b = 3</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-1000 &lt;= a, b &lt;= 1000</code></li></ul><h1>解题</h1><p>不使用<code>+</code>、<code>-</code>算术运算符，通过位运算可以实现加法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0+0=0，0+1=1，1+0=1，1+1=0（进位）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> (a &amp; b) &lt;&lt; <span class="number">1</span>; <span class="comment">// 计算所有需要进位的 bit</span></span><br><span class="line">            a ^= b; <span class="comment">// 异或操作，相当于无进位加法</span></span><br><span class="line">            b = carry; <span class="comment">// 将进位应用于下一位相加</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了位运算中的异或（<code>^</code>）和与（<code>&amp;</code>）操作来模拟不带进位的加法。</p><p>具体步骤如下：</p><ol><li><code>(a &amp; b) &lt;&lt; 1</code> 计算出所有需要进位的 <code>bit</code>，将其左移一位，得到进位值（因为只有<code>1</code>和<code>1</code>与运算之后才是<code>1</code>）。</li><li><code>a ^= b</code> 对 a 和 b 进行异或操作，相当于不考虑进位的加法。</li><li><code>b = carry</code> 将进位应用于下一轮相加。</li></ol><p>这样，通过循环，直到没有进位为止，最终得到了两数之和。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4的幂</title>
      <link href="/2024/01/19/leetcode-342/"/>
      <url>/2024/01/19/leetcode-342/</url>
      
        <content type="html"><![CDATA[<h1>题目</h1><p><a href="https://leetcode.cn/problems/power-of-four/description/">342. 4的幂 - 力扣（LeetCode）</a></p><p>给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>整数 <code>n</code> 是 4 的幂次方需满足：存在整数 <code>x</code> 使得 <code>n == 4x</code></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 16</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-2^31 &lt;= n &lt;= 2^31 - 1</code></li></ul><p>**进阶：**你能不使用循环或者递归来完成本题吗？</p><h1>解题</h1><p>在位运算章节中我们<a href="https://zheng-yi-yi.github.io/2024/01/16/dsa-01-Bit-operations/#%E5%88%A4%E6%96%AD%E7%BB%99%E5%AE%9A%E6%95%B0-n-%E6%98%AF%E5%90%A6%E4%B8%BA-2-%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0%E6%AC%A1%E5%B9%82">讲过</a>，要想判断给定数 <code>n</code> 是否为 <code>2</code> 的正整数次幂，只需这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，位运算技巧<code>n &amp; (n - 1)</code>可以直接将 <code>n</code> 二进制表示的最低位 <code>1</code> 移除。</p><p>现在，我们要来判断一个数<code>n</code>是否是 4 的幂次方。这该怎么算？</p><p>通过观察我们发现，如果<code>n</code>是 4 的幂，那么<code>n</code>的二进制表示中，<code>1</code>所在的位置一定是从低位开始的<strong>第偶数个</strong>二进制位上（注意，最低位规定是第<code>0</code>位）。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 4 = &#123;100&#125;</span><br><span class="line">16 = &#123;10000&#125;</span><br><span class="line">32 = &#123;1000000&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>因此，我们只需构造一个所有<strong>偶数二进制位都是<code>0</code></strong>，奇数二进制位都是<code>1</code>的数字<code>mask</code>，然后将这个数字和<code>n</code>进行按位与运算。</p><p>如果结果是<code>0</code>，那么这个数<code>n</code>一定是 4 的幂次方（因为其二进制位中<code>1</code>出现的位置是偶数位）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mask = &#123;10101010101010101010101010101010&#125;2 = &#123;AAAAAAAA&#125;16</span><br></pre></td></tr></table></figure><p>解题代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfFour</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n-<span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; (n &amp; <span class="number">0xaaaaaaaa</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字范围按位与</title>
      <link href="/2024/01/19/leetocde-201/"/>
      <url>/2024/01/19/leetocde-201/</url>
      
        <content type="html"><![CDATA[<h1>题目</h1><p><a href="https://leetcode.cn/problems/bitwise-and-of-numbers-range/description/">201. 数字范围按位与 - 力扣（LeetCode）</a></p><p>给你两个整数 <code>left</code> 和 <code>right</code> ，表示区间 <code>[left, right]</code> ，返回此区间内所有数字 <strong>按位与</strong> 的结果（包含 <code>left</code> 、<code>right</code> 端点）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：left = 5, right = 7</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：left = 0, right = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：left = 1, right = 2147483647</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= left &lt;= right &lt;= 2^31 - 1</code></li></ul><h1>解题</h1><p>这道题如果按照迭代区间的每一个元素，然后按位进行与运算，会超时。因此需要优化。</p><p>我们观察发现，将每个数字用二进制表示后对齐，逐位遍历比特位上的值，只要某一列上出现一个<code>0</code>，那么<strong>与运算</strong>之后的结果在该位上也一定是<code>0</code>。</p><p><img src="/images/leetcode/leetocde-201.png" alt="leetocde-201.png"></p><p>因此，这个问题就转换为：给定两个整数，找到它们对应的二进制字符串的公共前缀，然后将剩余位补零。</p><p>在实际编码中，我们让两个数字不断右移，直到相等，就得到了公共前缀，此时再左移补零。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left != right) &#123;</span><br><span class="line">            k++;</span><br><span class="line">            left &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            right &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left &lt;&lt; k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻转矩阵后的得分</title>
      <link href="/2024/01/19/leetcode-861/"/>
      <url>/2024/01/19/leetcode-861/</url>
      
        <content type="html"><![CDATA[<h1>题目</h1><p><a href="https://leetcode.cn/problems/score-after-flipping-matrix/description/">861. 翻转矩阵后的得分 - 力扣（LeetCode）</a></p><p>给你一个大小为 <code>m x n</code> 的二元矩阵 <code>grid</code> ，矩阵中每个元素的值为 <code>0</code> 或 <code>1</code> 。</p><p>一次 <strong>移动</strong> 是指选择任一行或列，并转换该行或列中的每一个值：将所有 <code>0</code> 都更改为 <code>1</code>，将所有 <code>1</code> 都更改为 <code>0</code>。</p><p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的 <strong>得分</strong> 就是这些数字的总和。</p><p>在执行任意次 <strong>移动</strong> 后（含 0 次），返回可能的最高分数。</p><p><strong>示例 1：</strong></p><p><img src="/images/leetcode/leetcode-861.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]</span><br><span class="line">输出：39</span><br><span class="line">解释：0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[0]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 20</code></li><li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li></ul><h1>解题</h1><p>这道题使用了贪心策略。</p><p>首先我们知道，矩阵有<code>m</code>行<code>n</code>列。这里我们设首列（最左边的列）是第<code>0</code>列。</p><p>贪心思路是这样的：</p><ul><li>将首列全部变为<code>1</code>（为了得到最高的分数）</li><li>接着对于后续每一列，我们都让该列上<code>1</code>的数目尽可能的多（如果该列上<code>0</code>的数目多于<code>1</code>的数目，就翻转该列）</li></ul><p>在实际编码时，我们是这样实现的：</p><ol><li>首先，我们初始化结果变量<code>ret</code>为矩阵的行数<code>m</code>乘以2的n-1次方。因为我们首先将首列全部变为1嘛，而首列的权值是<code>2^(n-1)</code>。</li><li>接着，对于后续的每一列（从第一列开始遍历到最后一列）：<ol><li>我们统计当前列中<code>1</code>的数量以及<code>0</code>的数量。</li><li>然后取两者中较大的值，我们设为<code>k</code>，<code>k</code>就是翻转后<code>1</code>的数量。</li><li>然后将<code>k</code>乘以<code>2</code>的<code>n-j-1</code>次方，再累加到<code>ret</code>变量即可。</li></ol></li><li>最终将<code>ret</code>变量返回。</li></ol><blockquote><p>在计算每一列上<code>1</code>的数量时，我们是这么计算的：</p><ol><li>如果首列的元素是<code>1</code>，直接加上当前列的值</li><li>如果首列的元素是<code>0</code>，则需要加上当前列值为<code>0</code>的元素个数（这是因为首列元素为0，则需要翻转该行将首列元素变为<code>1</code>。那么该行上为<code>0</code>的元素翻转后就是<code>1</code>了）。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">matrixScore</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> m * (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;n; j++) &#123;  <span class="comment">// 遍历每一列 j</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nOnes</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;m; i++) &#123;  <span class="comment">// 遍历每一行 i</span></span><br><span class="line">                <span class="keyword">if</span>(grid[i][<span class="number">0</span>] == <span class="number">1</span>) nOnes+= grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> nOnes += (<span class="number">1</span> - grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> Math.max(nOnes, m-nOnes);</span><br><span class="line">            ret += k * (<span class="number">1</span>&lt;&lt;(n-j-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找到两个数组的前缀公共数组</title>
      <link href="/2024/01/18/leetcode-2657/"/>
      <url>/2024/01/18/leetcode-2657/</url>
      
        <content type="html"><![CDATA[<h1>题目</h1><p><a href="https://leetcode.cn/problems/find-the-prefix-common-array-of-two-arrays/description/">2657. 找到两个数组的前缀公共数组 - 力扣（LeetCode）</a></p><p>给你两个下标从 <strong>0</strong> 开始长度为 <code>n</code> 的整数排列 <code>A</code> 和 <code>B</code> 。</p><p><code>A</code> 和 <code>B</code> 的 <strong>前缀公共数组</strong> 定义为数组 <code>C</code> ，其中 <code>C[i]</code> 是数组 <code>A</code> 和 <code>B</code> 到下标为 <code>i</code> 之前公共元素的数目。</p><p>请你返回 <code>A</code> 和 <code>B</code> 的 <strong>前缀公共数组</strong> 。</p><p>如果一个长度为 <code>n</code> 的数组包含 <code>1</code> 到 <code>n</code> 的元素恰好一次，我们称这个数组是一个长度为 <code>n</code> 的 <strong>排列</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1,3,2,4], B = [3,1,2,4]</span><br><span class="line">输出：[0,2,3,4]</span><br><span class="line">解释：i = 0：没有公共元素，所以 C[0] = 0 。</span><br><span class="line">i = 1：1 和 3 是两个数组的前缀公共元素，所以 C[1] = 2 。</span><br><span class="line">i = 2：1，2 和 3 是两个数组的前缀公共元素，所以 C[2] = 3 。</span><br><span class="line">i = 3：1，2，3 和 4 是两个数组的前缀公共元素，所以 C[3] = 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [2,3,1], B = [3,1,2]</span><br><span class="line">输出：[0,1,3]</span><br><span class="line">解释：i = 0：没有公共元素，所以 C[0] = 0 。</span><br><span class="line">i = 1：只有 3 是公共元素，所以 C[1] = 1 。</span><br><span class="line">i = 2：1，2 和 3 是两个数组的前缀公共元素，所以 C[2] = 3 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= A.length == B.length == n &lt;= 50</code></li><li><code>1 &lt;= A[i], B[i] &lt;= n</code></li><li>题目保证 <code>A</code> 和 <code>B</code> 两个数组都是 <code>n</code> 个元素的排列。</li></ul><h1>解题</h1><p>首先我们观察到，两个数组都分别是整数<code>1</code>到<code>n</code>的排列（数组中各元素互不相同）。</p><p>解题思路：</p><p>设所求数组为<code>ans</code></p><p>从左到右遍历数组A和B，在每轮循环中：</p><ul><li>将<code>A[i]</code>和<code>B[i]</code>分别放入集合<code>A</code>以及集合<code>B</code></li><li>接着计算两个集合中相同元素的个数，将这个值赋给<code>ans[i]</code></li></ul><p>最后返回<code>ans</code>即可。</p><p>这里由于数组<code>A</code>和<code>B</code>的长度都不超过<code>50</code>，因此我们可以用位运算来优化操作。</p><p>用<code>mask</code>二进制位上的<code>1</code>和<code>0</code>来表示元素是否存在集合中，用 <code>&amp;</code> 运算求出集合的交集，最后按照二进制位中<code>1</code>的个数来表示交集元素的数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findThePrefixCommonArray(<span class="type">int</span>[] A, <span class="type">int</span>[] B) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> A.length;</span><br><span class="line">        <span class="type">long</span> <span class="variable">maska</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">maskb</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="comment">// 将元素所在的位置加入集合mask中</span></span><br><span class="line">            maska |= (<span class="number">1L</span> &lt;&lt; A[i]);</span><br><span class="line">            maskb |= (<span class="number">1L</span> &lt;&lt; B[i]);</span><br><span class="line"><span class="comment">// 求出两个集合的交集，并且数出1的数量</span></span><br><span class="line">            ans[i] = Long.bitCount(maska &amp; maskb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使数组异或和等于 K 的最少操作次数</title>
      <link href="/2024/01/17/leetcode-2997/"/>
      <url>/2024/01/17/leetcode-2997/</url>
      
        <content type="html"><![CDATA[<h1>题目</h1><p><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-xor-equal-to-k/description/">2997. 使数组异或和等于 K 的最少操作次数 - 力扣（LeetCode）</a></p><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个正整数 <code>k</code> 。</p><p>你可以对数组执行以下操作 <strong>任意次</strong> ：</p><ul><li>选择数组里的 <strong>任意</strong> 一个元素，并将它的 <strong>二进制</strong> 表示 <strong>翻转</strong> 一个数位，翻转数位表示将 <code>0</code> 变成 <code>1</code> 或者将 <code>1</code> 变成 <code>0</code> 。</li></ul><p>你的目标是让数组里 <strong>所有</strong> 元素的按位异或和得到 <code>k</code> ，请你返回达成这一目标的 <strong>最少</strong> 操作次数。</p><p><strong>注意</strong>，你也可以将一个数的前导 0 翻转。比方说，数字 <code>(101)2</code> 翻转第四个数位，得到 <code>(1101)2</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,1,3,4], k = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：我们可以执行以下操作：</span><br><span class="line">- 选择下标为 2 的元素，也就是 3 == (011)2 ，我们翻转第一个数位得到 (010)2 == 2 。数组变为 [2,1,2,4] 。</span><br><span class="line">- 选择下标为 0 的元素，也就是 2 == (010)2 ，我们翻转第三个数位得到 (110)2 == 6 。数组变为 [6,1,2,4] 。</span><br><span class="line">最终数组的所有元素异或和为 (6 XOR 1 XOR 2 XOR 4) == 1 == k 。</span><br><span class="line">无法用少于 2 次操作得到异或和等于 k 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,0,2,0], k = 0</span><br><span class="line">输出：0</span><br><span class="line">解释：数组所有元素的异或和为 (2 XOR 0 XOR 2 XOR 0) == 0 == k 。所以不需要进行任何操作。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>0 &lt;= nums[i] &lt;= 10^6</code></li><li><code>0 &lt;= k &lt;= 10^6</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>解题</h1><p>让数组<code>nums</code>里<strong>所有</strong>元素的按位异或后的结果，我们设为 <code>res</code>。</p><p><code>res</code>等于<code>k</code>，等价于二者异或后为0。因为对于异或操作来说，两个相同的数异或，结果为0。</p><p>因此我们可以让<code>res</code>和<code>k</code>进行异或得到<code>ans</code>，然后看看<code>ans</code>中有几个1，我们将这些1翻转为0即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 计算给定数字的二进制表示形式中 1 的数量，也可以调用Integer.bitCount()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOneCount</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n &amp;= n-<span class="number">1</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            res ^= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> res ^ k;</span><br><span class="line">        <span class="keyword">return</span> getOneCount(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计一致字符串的数目</title>
      <link href="/2024/01/17/leetcode-1684/"/>
      <url>/2024/01/17/leetcode-1684/</url>
      
        <content type="html"><![CDATA[<h1>题目</h1><p><a href="https://leetcode.cn/problems/count-the-number-of-consistent-strings/description/">1684. 统计一致字符串的数目 - 力扣（LeetCode）</a></p><p>给定一个由不同字符组成的字符串 <code>allowed</code> 和一个字符串数组 <code>words</code>，如果一个字符串的每一个字符都在 <code>allowed</code> 中，就称这个字符串是一致字符串。请你返回 <code>words</code> 数组中一致字符串的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：allowed = &quot;ab&quot;, words = [&quot;ad&quot;,&quot;bd&quot;,&quot;aaab&quot;,&quot;baa&quot;,&quot;badab&quot;]</span><br><span class="line">输出：2</span><br><span class="line">解释：字符串 &quot;aaab&quot; 和 &quot;baa&quot; 都是一致字符串，因为它们只包含字符 &#x27;a&#x27; 和 &#x27;b&#x27; 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：allowed = &quot;abc&quot;, words = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;ab&quot;,&quot;ac&quot;,&quot;bc&quot;,&quot;abc&quot;]</span><br><span class="line">输出：7</span><br><span class="line">解释：所有字符串都是一致的。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：allowed = &quot;cad&quot;, words = [&quot;cc&quot;,&quot;acd&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bac&quot;,&quot;bad&quot;,&quot;ac&quot;,&quot;d&quot;]</span><br><span class="line">输出：4</span><br><span class="line">解释：字符串 &quot;cc&quot;，&quot;acd&quot;，&quot;ac&quot; 和 &quot;d&quot; 是一致字符串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= words.length &lt;= 10^4</code></li><li><code>1 &lt;= allowed.length &lt;= 26</code></li><li><code>1 &lt;= words[i].length &lt;= 10</code></li><li><code>allowed</code> 中的字符 <strong>互不相同</strong> 。</li><li><code>words[i]</code> 和 <code>allowed</code> 只包含小写英文字母。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countConsistentStrings</span><span class="params">(String allowed, String[] words)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>解题</h1><h2 id="字符集合的位表示">字符集合的位表示</h2><p>由于题目中说明字符串仅包含小写字母，我们可以使用位运算来表示字符串的字母集合。</p><p>通过一个 32 位整数<code>mask</code>来表示一个字符串的字母集合，其中每一位表示一个字母是否出现（如果一个字母出现了，那么将对应整数的位设1，否则就是0）。</p><h2 id="构建-allowed-的字母集合-mask">构建 allowed 的字母集合 mask</h2><p>首先，我们需要构建字符串 <code>allowed</code> 中出现的字母集合 <code>mask</code>。遍历 <code>allowed</code> 中的每个字符，将对应字母的二进制位置设为 1，得到一个整数 <code>mask</code>，表示 <code>allowed</code> 中出现的字母集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; allowed.length(); i++) &#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> allowed.charAt(i);</span><br><span class="line">    mask |= <span class="number">1</span> &lt;&lt; (c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历-words-数组，统计一致字符串的数目">遍历 words 数组，统计一致字符串的数目</h2><p>然后，我们遍历 <code>words</code> 数组，对于每个字符串 <code>word</code>，构建其字母集合 <code>mask1</code>，并通过 <code>(mask1 | mask) == mask</code> 判断 <code>mask1</code> 是否是 <code>mask</code> 的子集，如果是，则说明该字符串是一致字符串，将结果 <code>res</code> 增加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mask1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">        mask1 |= <span class="number">1</span> &lt;&lt; (c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((mask1 | mask) == mask) &#123;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，返回统计得到的一致字符串的数目。</p><h2 id="完整代码">完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 获取字符串的字母集合 mask</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMask</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> word.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            mask |= <span class="number">1</span> &lt;&lt; (c - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计一致字符串的数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countConsistentStrings</span><span class="params">(String allowed, String[] words)</span> &#123;</span><br><span class="line">        <span class="comment">// 构建 allowed 的字母集合 allowedMask</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">allowedMask</span> <span class="operator">=</span> getMask(allowed);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> words.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 words 数组，统计一致字符串的数目</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取当前字符串的字母集合 curMask</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">curMask</span> <span class="operator">=</span> getMask(words[i]);</span><br><span class="line">            <span class="comment">// 判断 curMask 是否是 allowedMask 的子集</span></span><br><span class="line">            <span class="keyword">if</span> ((allowedMask | curMask) == allowedMask) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一致字符串的数目</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作后的最大异或和</title>
      <link href="/2024/01/17/leetcode-2317/"/>
      <url>/2024/01/17/leetcode-2317/</url>
      
        <content type="html"><![CDATA[<h1>题目</h1><p><a href="https://leetcode.cn/problems/maximum-xor-after-operations/">2317. 操作后的最大异或和 - 力扣（LeetCode）</a></p><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。一次操作中，选择 <strong>任意</strong> 非负整数 <code>x</code> 和一个下标 <code>i</code> ，<strong>更新</strong> <code>nums[i]</code> 为 <code>nums[i] AND (nums[i] XOR x)</code> 。</p><p>注意，<code>AND</code> 是逐位与运算，<code>XOR</code> 是逐位异或运算。</p><p>请你执行 <strong>任意次</strong> 更新操作，并返回 <code>nums</code> 中所有元素 <strong>最大</strong> 逐位异或和。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4,6]</span><br><span class="line">输出：7</span><br><span class="line">解释：选择 x = 4 和 i = 3 进行操作，num[3] = 6 AND (6 XOR 4) = 6 AND 2 = 2 。</span><br><span class="line">现在，nums = [3, 2, 4, 2] 且所有元素逐位异或得到 3 XOR 2 XOR 4 XOR 2 = 7 。</span><br><span class="line">可知 7 是能得到的最大逐位异或和。</span><br><span class="line">注意，其他操作可能也能得到逐位异或和 7 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,9,2]</span><br><span class="line">输出：11</span><br><span class="line">解释：执行 0 次操作。</span><br><span class="line">所有元素的逐位异或和为 1 XOR 2 XOR 3 XOR 9 XOR 2 = 11 。</span><br><span class="line">可知 11 是能得到的最大逐位异或和。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>0 &lt;= nums[i] &lt;= 10^8</code></li></ul><hr><h1>解题</h1><p>这道题有点脑筋急转弯的感觉。</p><p>要想获得<strong>最大逐位异或和</strong>（我们设为<code>ans</code>），就必须尽可能的保留更多异或后的1的个数。</p><p>我们再来看这个运算操作：<code>nums[i] AND (nums[i] XOR x)</code></p><p>实际上：</p><ul><li><code>nums[i] XOR x</code>等同于将<code>nums[i]</code>修改为任意非负整数。</li><li><code>num[i] AND ???</code> 等同于修改<code>nums[i]</code>的某些比特位（由1修改为0）</li></ul><p>由于我们想要<strong>尽可能的保留更多异或后的1的个数</strong>。因此必须使得二进制位上<code>1</code>的个数要是奇数。因此<code>nums[i] AND (nums[i] XOR x)</code>操作就是将某些比特位上的<code>1</code>修改为<code>0</code>，从而使得该位上的<code>1</code>是奇数个，最终异或结果里该位上才是<code>1</code>。</p><p>因此我们发现，这道题目要求的最大逐位异或和，实际上等价于对数组中每个元素的所有二进制位，只要某一位在数组中出现过 <code>1</code>，那么答案里这一位也是 <code>1</code>，得到的结果才达到最大。</p><p>因此我们可以用逐位<strong>或</strong>运算来尽最大努力保留每一位上的<code>1</code>。</p><p>代码很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumXOR</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            ans = i | ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2024/01/16/dsa-01-Bit-operations/"/>
      <url>/2024/01/16/dsa-01-Bit-operations/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%E5%89%8D%E8%A8%80">前言</a><ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li><li><a href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">位运算符</a></li><li><a href="#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97">移位运算</a></li></ul></li><li><a href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C">位运算操作</a><ul><li><a href="#%E5%88%A4%E6%96%AD%E7%BB%99%E5%AE%9A%E6%95%B0-n-%E6%98%AF%E5%90%A6%E4%B8%BA-2-%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0%E6%AC%A1%E5%B9%82">判断给定数 n 是否为 2 的正整数次幂</a></li><li><a href="#%E8%AE%A1%E7%AE%97%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F%E4%B8%AD-1-%E7%9A%84%E6%95%B0%E9%87%8F">计算给定数字的二进制表示形式中 1 的数量</a></li><li><a href="#%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E4%B8%AD%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E5%AD%90%E9%9B%86">生成一个集合中所有可能的子集</a></li><li><a href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E9%81%8D%E5%8E%86">位运算遍历</a></li><li><a href="#%E5%8F%96%E5%87%BA%E6%95%B4%E6%95%B0-n-%E5%9C%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%8B%E7%9A%84%E7%AC%AC-k-%E4%BD%8D">取出整数 n 在二进制表示下的第 k 位</a></li><li><a href="#%E5%B0%86%E6%95%B4%E6%95%B0-n-%E5%9C%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%8B%E7%9A%84%E7%AC%AC-k-%E4%BD%8D%E5%8F%96%E5%8F%8D">将整数 n 在二进制表示下的第 k 位取反</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E6%95%B4%E6%95%B0%E7%9A%84%E4%BD%8E%E4%BD%8D%E9%83%A8%E5%88%86">获取整数的低位部分</a></li><li><a href="#%E4%BD%8D%E8%B5%8B%E5%80%BC1%E6%93%8D%E4%BD%9C">位赋值1操作</a></li><li><a href="#%E4%BD%8D%E8%B5%8B%E5%80%BC0%E6%93%8D%E4%BD%9C">位赋值0操作</a></li><li><a href="#%E6%88%90%E5%AF%B9%E5%8F%98%E6%8D%A2">成对变换</a></li><li><a href="#%E8%BF%94%E5%9B%9E%E6%95%B4%E6%95%B0-n-%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F%E4%B8%AD%E6%9C%80%E5%8F%B3%E8%BE%B9%E7%9A%841">返回整数 n 的二进制表示形式中最右边的1</a></li></ul></li><li><a href="#%E5%86%8D%E8%B0%88%E5%BC%82%E6%88%96">再谈异或</a><ul><li><a href="#%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97">基本运算</a></li><li><a href="#%E6%9F%90%E4%B8%AA%E6%95%B0%E5%87%BA%E7%8E%B0%E5%A5%87%E6%95%B0%E6%AC%A1">某个数出现奇数次</a></li><li><a href="#%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%87%BA%E7%8E%B0%E5%A5%87%E6%95%B0%E6%AC%A1">两个数出现奇数次</a></li><li><a href="#%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0">交换两个数</a></li></ul></li><li><a href="#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99">学习资料</a></li></ul><h1>前言</h1><blockquote><p><strong>Powers of Two</strong></p></blockquote><img src="/2024/01/16/dsa-01-Bit-operations/powersoftwo.png" class="" title="powersoftwo"><blockquote><p><strong>Logical</strong></p></blockquote><img src="/2024/01/16/dsa-01-Bit-operations/logical.png" class="" title="logical"><blockquote><p><strong>Bit Manipulation</strong></p></blockquote><img src="/2024/01/16/dsa-01-Bit-operations/bitmanipulation.png" class="" title="bitmanipulation"><blockquote><p><strong>Mask Creation</strong></p></blockquote><img src="/2024/01/16/dsa-01-Bit-operations/mask.png" class="" title="mask"><h2 id="概述">概述</h2><blockquote><p>“bit是度量信息的单位，包含 0 和 1 两种状态。计算机的各种运算最后无不归结为一个个bit的变化。”</p></blockquote><p>位运算速度更快，更接近系统，有时可以将程序优化到一个很好的水平。</p><p>我们约定，在 <code>m</code> 位二进制数中，最低位称为第 <code>0</code> 位，从右到左依次类推，则最高位是第 <code>m-1</code> 位。</p><h2 id="位运算符">位运算符</h2><p>下面，复习一下位运算符：</p><table><thead><tr><th>与</th><th>或</th><th>非</th><th>异或</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td><code>|</code></td><td><code>~</code></td><td><code>^</code></td></tr><tr><td>如果相对应位都是1，则结果为1，否则为0</td><td>如果相对应位都是 0，则结果为 0，否则为 1</td><td>按位取反运算符翻转操作数的每一位，即0变成1，1变成0</td><td>如果相对应位值不同，则结果为1，否则为0</td></tr></tbody></table><img src="/2024/01/16/dsa-01-Bit-operations/image.png" class="" title="位运算符"><h2 id="移位运算">移位运算</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PowerFunctions</span> &#123;</span><br><span class="line">    <span class="comment">// 计算 n 乘以 2 的 m 次方</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">multiplyByPowerOfTwo</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n &lt;&lt; m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 n 除以 2 的 m 次方</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">divideByPowerOfTwo</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt;&gt; m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 示例用法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">resultMultiply</span> <span class="operator">=</span> multiplyByPowerOfTwo(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 5 * 2^3 = 40</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">resultDivide</span> <span class="operator">=</span> divideByPowerOfTwo(<span class="number">32</span>, <span class="number">3</span>);    <span class="comment">// 32 / 2^3 = 4</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;5 * 2^3 = &quot;</span> + resultMultiply);</span><br><span class="line">        System.out.println(<span class="string">&quot;32 / 2^3 = &quot;</span> + resultDivide);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 * 2^3 = 40</span><br><span class="line">32 / 2^3 = 4</span><br></pre></td></tr></table></figure><blockquote><p><strong>左移，在二进制表示下把数字同时向左移动，低位用 0 填充，高位越界后舍弃</strong>。</p></blockquote><p>将一个数左移 <code>n</code> 位，相当于乘上 <code>2</code> 的 <code>n</code> 次方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">7</span>&lt;&lt;<span class="number">3</span>);  <span class="comment">// 56，即 7 * (2^3)</span></span><br></pre></td></tr></table></figure><p>将 <code>1</code> 左移 <code>n</code> 位后得到的值等于 <code>2</code> 的 <code>n</code> 次方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">1</span>&lt;&lt;<span class="number">10</span>);  <span class="comment">// 1024，即2的10次方</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>右移，在二进制表示下把数字同时向右移动，高位以符号位填充，低位越界后舍弃</strong>。</p></blockquote><p>将某个数右移 <code>1</code> 位相当于除以 <code>2</code> 再向下取整。</p><p>比如 <code>3&gt;&gt;1</code> 相当于 <code>3</code> 除以 <code>2</code> 等于 <code>1.5</code> 再向下取整得到 <code>1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">3</span>&gt;&gt;<span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><code>-3&gt;&gt;1</code> 相当于 <code>-3</code> 除以 <code>2</code> 等于 <code>-1.5</code> 再向下取整得到 <code>-2</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(-<span class="number">3</span>&gt;&gt;<span class="number">1</span>); <span class="comment">// -2</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>值得一提的是，在Java中，“整数/2”会舍弃小数位。比如 <code>-3/2</code> 的结果为 -1</strong>。这和右移操作（除以2后向下取整）的结果不一样，存在区别。</p></blockquote><p>将一个数右移 <code>n</code> 位，相当于乘以 <code>2</code> 的 <code>n</code> 次方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">64</span>&gt;&gt;<span class="number">3</span>);  <span class="comment">// 8，即 64 / (2^3)</span></span><br></pre></td></tr></table></figure><h1>位运算操作</h1><h2 id="判断给定数-n-是否为-2-的正整数次幂">判断给定数 n 是否为 2 的正整数次幂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>n</code> 是 <code>2</code> 的幂，则 <code>n &amp; (n-1)</code> 的结果应为 <code>0</code>。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   x  = 4 = (0100)2</span><br><span class="line">  x-1 = 3 = (0011)2</span><br><span class="line"></span><br><span class="line">   0 1 0 0      4</span><br><span class="line">&amp;  0 0 1 1      3</span><br><span class="line">-----------</span><br><span class="line">   0 0 0 0      0</span><br></pre></td></tr></table></figure><h2 id="计算给定数字的二进制表示形式中-1-的数量">计算给定数字的二进制表示形式中 1 的数量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">count_one</span> <span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        n = n &amp; (n-<span class="number">1</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在循环体内，执行位操作 <code>n = n &amp; (n-1)</code>，这会将 <code>n</code> 减去其二进制表示中最低位的 <code>1</code>。这一步目的是消除<code>n</code>最右边的 <code>1</code>，并在每次迭代中计算 <code>1</code> 的数量。</p><p>可以列举后理解。比如要求出<code>14</code>（<code>1110</code>）的二进制表示形式中 <code>1</code> 的数量，那么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">14 &amp; 13 = &#123;1 1 1 0&#125; &amp; &#123;1 1 0 1&#125; = &#123;1 1 0 0&#125; = 12</span><br><span class="line"></span><br><span class="line">12 &amp; 11 = &#123;1 1 0 0&#125; &amp; &#123;1 0 1 1&#125; = &#123;1 0 0 0&#125; = 8</span><br><span class="line"></span><br><span class="line"> 8 &amp; 7  = &#123;1 0 0 0&#125; &amp; &#123;0 1 1 1&#125; = &#123;0 0 0 0&#125; = 0</span><br></pre></td></tr></table></figure><p>一共循环3次，1 的数量为<code>3</code>。我们发现，每次执行<code>n = n &amp; (n-1)</code>操作后，都会消除其二进制表示中最右边的 <code>1</code>。</p><h2 id="生成一个集合中所有可能的子集">生成一个集合中所有可能的子集</h2><p>比如有一个集合<code>A</code>是<code>&#123;a, b, c&#125;</code>。</p><p>为了求出所有可能的子集，我们需要<code>3</code>位二进制数。并且约定<code>1</code>表示对应的元素存在于子集中，<code>0</code>表示对应的元素不存在于子集中。所有可能的组合如下：</p><ul><li><code>0 = (000) = &#123;&#125;</code></li><li><code>1 = (001) = &#123;c&#125;</code></li><li><code>2 = (010) = &#123;b&#125;</code></li><li><code>3 = (011) = &#123;b, c&#125;</code></li><li><code>4 = (100) = &#123;a&#125;</code></li><li><code>5 = (101) = &#123;a, c&#125;</code></li><li><code>6 = (110) = &#123;a, b&#125;</code></li><li><code>7 = (111) = &#123;a, b, c&#125;</code></li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">possibleSubsets</span> <span class="params">(<span class="type">char</span> A[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> A.length;   <span class="comment">// 有N个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历 2^n 次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;N); ++i) &#123;</span><br><span class="line">        <span class="comment">// 从最低位开始，检查每一位是否为 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt;N; ++j) &#123; </span><br><span class="line">            <span class="keyword">if</span>((i &amp; (<span class="number">1</span> &lt;&lt; j)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果当前这个二进制位是1，则将对应的元素加入子集</span></span><br><span class="line">                System.out.print(A[j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位运算遍历">位运算遍历</h2><p>使用 <code>n &amp; 1</code> 可以获取 <code>n</code> 在二进制表示下的最低位，而 <code>n &gt;&gt; 1</code> 可以舍去最低位，也就是将整数右移一位。结合这两个操作，可以<strong>逐位遍历</strong>整数 <code>n</code> 在二进制表示下的所有位，实现位运算遍历。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历整数 n 的二进制表示</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BitTraversalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">11</span>; <span class="comment">// 二进制表示为 1011</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从最低位开始遍历</span></span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lowestBit</span> <span class="operator">=</span> n &amp; <span class="number">1</span>;</span><br><span class="line">            System.out.print(lowestBit); <span class="comment">// 输出当前位的值</span></span><br><span class="line"></span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>; <span class="comment">// 右移一位，舍去最低位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，遍历过程输出的结果是 <code>1101</code>，即整数<code>11</code>在二进制下的各个位的值。</p><blockquote><p><strong>注意，由于是从最低位开始遍历，输出的结果是二进制表示的反向</strong>。</p></blockquote><p>如果你想要正向输出，可以将结果保存在数组或其他数据结构中，然后反向输出。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历整数 n 的二进制表示</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BitTraversalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">11</span>; <span class="comment">// 二进制表示为 1011</span></span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从最低位开始遍历</span></span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lowestBit</span> <span class="operator">=</span> n &amp; <span class="number">1</span>;</span><br><span class="line">            result.insert(<span class="number">0</span>, lowestBit); <span class="comment">// 插入到result的最前面</span></span><br><span class="line"></span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>; <span class="comment">// 右移一位，舍去最低位（也可以写成 n &gt;&gt;= 1）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;正向输出二进制表示: &quot;</span> + result.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正向输出二进制表示: 1011</span></span><br></pre></td></tr></table></figure><h2 id="取出整数-n-在二进制表示下的第-k-位">取出整数 n 在二进制表示下的第 k 位</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取出整数 n 在二进制表示下的第 k 位的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getBit</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (n &gt;&gt; k) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要判断某个数<code>n</code>某一位是1还是0（二进制表示下），可以将这个数<code>n</code>右移 <code>k</code> 位再和<code>1</code>进行<strong>与</strong>运算即可。</p><h2 id="将整数-n-在二进制表示下的第-k-位取反">将整数 n 在二进制表示下的第 k 位取反</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把整数 n 在二进制表示下的第 k 位取反</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">flipBit</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n ^ (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>1</code>左移<code>k</code>位得到的数值为<code>2</code>的<code>k</code>次幂，该数值在二进制表示下，只有第<code>k</code>位为<code>1</code>，其他位都为<code>0</code>。因此将这个数和<code>n</code>进行异或运算，即可将第 k 位取反。</p><blockquote><p><code>1^1=0，1^0=1</code></p></blockquote><p>比如，现在要将<code>6</code>（<code>0 1 1 0</code>）的第<code>3</code>位取反后变为<code>14</code>（<code>1 1 1 0</code>）。那么只需将<code>1</code>左移<code>3</code>位得到<code>8</code>（<code>1 0 0 0</code>），再和<code>8</code>和<code>6</code>进行异或，就可以得到<code>14</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 6 = &#123;0 1 1 0&#125;</span><br><span class="line"> 8 = &#123;1 0 0 0&#125;</span><br><span class="line">14 = &#123;1 1 1 0&#125;</span><br></pre></td></tr></table></figure><h2 id="获取整数的低位部分">获取整数的低位部分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取出整数 n 在二进制表示下的第 0 到 k-1 位（后 k 位）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getBits</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n &amp; ((<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如，现在要拿到<code>5</code>的后<code>2</code>位。只需将<code>1</code>左移<code>2</code>位得到<code>4</code>，再将<code>4</code>减<code>1</code>得到<code>3</code>，再拿<code>3</code>和<code>5</code>进行<strong>与运算</strong>即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 = &#123;0 1 0 1&#125;</span><br><span class="line">3 = &#123;0 0 1 1&#125;</span><br><span class="line">1 = &#123;0 0 0 1&#125;</span><br></pre></td></tr></table></figure><h2 id="位赋值1操作">位赋值1操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对整数 n 在二进制表示下表示的第 k 位赋值 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">setBitToOne</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n | (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// 对整数 n 在二进制表示下表示的第 k 位赋值 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">setBitToOne</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n | (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">8</span>;  <span class="comment">// 二进制表示为 1000</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 将第0位赋值为1（也就是将&quot;1000&quot;变为&quot;1001&quot;，即9）</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> setBitToOne(n, k);</span><br><span class="line">        System.out.println(result);<span class="comment">// 9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位赋值0操作">位赋值0操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对整数 n 在二进制表示下表示的第 k 位赋值 0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">setBitToZero</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n &amp; (~(<span class="number">1</span> &lt;&lt; k));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="comment">// 对整数 n 在二进制表示下表示的第 k 位赋值 0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">setBitToZero</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n &amp; (~(<span class="number">1</span> &lt;&lt; k));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">// 二进制表示为 1010</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 将第1位赋值为0（也就是将&quot;1010&quot;变为&quot;1000&quot;，即8）</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> setBitToZero(n, k);</span><br><span class="line">        System.out.println(result);<span class="comment">// 8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成对变换">成对变换</h2><p>通过计算可以发现，对于非负整数 <code>n</code>：</p><ol><li>当 <code>n</code> 为<strong>偶数</strong>时：</li></ol><ul><li><code>n ^ 1</code> 等于 <code>n + 1</code>。</li><li>比如 <code>n = 2</code>，<code>2 ^ 1</code> 等于 <code>3</code>。</li></ul><ol><li>当 <code>n</code> 为<strong>奇数</strong>时：</li></ol><ul><li><code>n ^ 1</code> 等于 <code>n - 1</code>。</li><li>比如 <code>n = 3</code>，<code>3 ^ 1</code> 等于 <code>2</code>。</li></ul><p>因此，<code>&quot;0与1&quot;</code>，<code>&quot;2与3&quot;</code>，<code>&quot;4与5&quot;</code>…关于<code>^ 1</code>运算构成 “成对变换”。这种成对的变换性质在涉及到奇偶性质的问题中或者某些特殊情境下会派上用场。</p><h2 id="返回整数-n-的二进制表示形式中最右边的1">返回整数 n 的二进制表示形式中最右边的1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回整数 n 的二进制表示形式中，最右边的1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getRightmostSetBit</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在补码表示法中，负数的表示是其正数的补码，即取反加一。</p></blockquote><p>我们来举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   n     = &#123;1 0 1 0&#125; =  10</span><br><span class="line">  -n     = &#123;0 1 1 0&#125; = -10</span><br><span class="line">n &amp; (-n) = &#123;0 0 1 0&#125; =  2</span><br></pre></td></tr></table></figure><h1>再谈异或</h1><h2 id="基本运算">基本运算</h2><blockquote><p>异或运算，相同位为0，不同位为1。</p></blockquote><p>首先，在异或运算中，对于任意二进制位<code>x</code>：</p><ul><li><code>x ^ 0 = x</code></li><li><code>x ^ 1 = ~x</code></li></ul><h2 id="某个数出现奇数次">某个数出现奇数次</h2><p>对于任意整数 <code>a</code>，有以下性质：</p><p><code>a^a=0</code></p><p>这表示一个数与自身进行异或运算的结果为零。</p><p>因此，如果对相同的数进行两次异或运算：</p><p><code>a^a^a=a^(a^a)=a^0=a</code></p><p>同样的:</p><p><code>a^b^b=a^(b^b)=a^0=a</code></p><p>因此，如果一个集合中某个数出现奇数次，其他数都出现偶数次，那么可以用异或算法，求出这个<strong>出现奇数次</strong>的数字：</p><blockquote><p>异或相同的数两次会互相抵消</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printOddTimesNum</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">eO</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> cur : arr) &#123;</span><br><span class="line">eO ^= cur;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(eO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个数出现奇数次">两个数出现奇数次</h2><p>现在又有一道<a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/description/">题目</a>：</p><p>如果一个集合中 <code>a</code> 出现了奇数次，<code>b</code> 也出现了奇数次，其他数字都出现了偶数次，那么求出 <code>a</code> 和 <code>b</code> 是多少？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printOddTimesNum2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">eor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> cur : arr) &#123;</span><br><span class="line">eor ^= cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时 eor = a ^ b</span></span><br><span class="line"><span class="comment">// 下面这个 rightOne 代表取出 eor 中最右侧为 1 的数，比如 1011010 取出后就等于 0000010 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">rightOne</span> <span class="operator">=</span> eor &amp; (~eor + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 下面以 rightOne 为分界线，分出哪些是 a 这边区域的，哪些是 b这边区域的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> cur : arr) &#123;</span><br><span class="line"><span class="keyword">if</span> ((cur &amp; rightOne) != <span class="number">0</span>) &#123;</span><br><span class="line">ans ^= cur;<span class="comment">// 最后异或完的结果 ans 不是 a 就是 b</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">other</span> <span class="operator">=</span> eor ^ ans;</span><br><span class="line">System.out.println(ans + <span class="string">&quot; &quot;</span> + other);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解题思路：</p><ul><li>通过异或操作，可以将数组中所有出现偶数次的数互相抵消，最终得到的结果<code>eor</code>就是两个出现奇数次的数的异或结果<code>a^b</code>。</li><li>然后，通过找到异或结果<code>a^b</code>中的一个为<code>1</code>的位，<strong>将数组中的数分为两组，分别包含 <code>a</code> 和 <code>b</code></strong>（这一步很关键，就是找到一个分界线，这个分界线可以取 <code>eor</code> 上的最右侧位数为 <code>1</code> 的数字）。</li><li>最后再对这两组数分别执行异或运算，得到 <code>a</code> 和 <code>b</code>。</li></ul><h2 id="交换两个数">交换两个数</h2><p>我们再来看异或运算的另一个技巧，<strong>交换两个数</strong>：</p><img src="/2024/01/16/dsa-01-Bit-operations/swapNumbers.png" class="" title="swapNumbers"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] swapNumbers(<span class="type">int</span>[] A) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上呢，这道题就是经典的异或运算特性题。解题代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异或运算：相同为 0，不同为 1。还可以理解为无进位加一，比如1+0=1、1+1=0(注意不进位)</span></span><br><span class="line"><span class="comment"> * 性质：</span></span><br><span class="line"><span class="comment"> * 0 ^ N = N </span></span><br><span class="line"><span class="comment"> * N ^ N = 0</span></span><br><span class="line"><span class="comment"> * a ^ b = b ^ a</span></span><br><span class="line"><span class="comment"> * a ^ b ^ c = a ^ (b ^ c)</span></span><br><span class="line"><span class="comment"> * 基于以上性质，我们来理解一下这个swapNumbers函数的运行过程：</span></span><br><span class="line"><span class="comment"> * a: 甲</span></span><br><span class="line"><span class="comment"> * b: 乙</span></span><br><span class="line"><span class="comment"> * a = a ^ b→a: 甲 ^ 乙    b: 乙</span></span><br><span class="line"><span class="comment"> * b = a ^ b→a: 甲 ^ 乙    b: 甲 ^ 乙 ^ 乙 = 甲</span></span><br><span class="line"><span class="comment"> * a = a ^ b→a: 甲 ^ 乙 ^ 甲 = 乙    b: 甲</span></span><br><span class="line"><span class="comment"> * a: 乙</span></span><br><span class="line"><span class="comment"> * b: 甲</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] swapNumbers(<span class="type">int</span>[] A) &#123;</span><br><span class="line">        A[<span class="number">0</span>] = A[<span class="number">0</span>] ^ A[<span class="number">1</span>];</span><br><span class="line">        A[<span class="number">1</span>] = A[<span class="number">0</span>] ^ A[<span class="number">1</span>];</span><br><span class="line">        A[<span class="number">0</span>] = A[<span class="number">0</span>] ^ A[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>学习资料</h1><p>灵神：<a href="https://leetcode.cn/circle/discuss/CaOJ45/">分享｜从集合论到位运算，常见位运算技巧分类总结！ - 力扣（LeetCode）</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法竞赛 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/01/16/hello-world/"/>
      <url>/2024/01/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
